6cbaf3d328064c61d7e8bd731d4d7ff1
"use strict";
/**
 * Unit tests for PDF Utility Functions
 */
Object.defineProperty(exports, "__esModule", { value: true });
const globals_1 = require("@jest/globals");
// Mock PDF.js for testing
jest.mock('pdfjs-dist', () => ({
    getDocument: jest.fn(),
    GlobalWorkerOptions: {
        workerSrc: ''
    }
}));
const pdfUtils_1 = require("../../../src/common/utils/pdfUtils");
describe('PDF Utilities', () => {
    describe('validatePDFBytes', () => {
        it('should return true for valid PDF bytes', () => {
            // Create a minimal valid PDF header
            const validPDFBytes = new Uint8Array([
                0x25, 0x50, 0x44, 0x46, 0x2D, 0x31, 0x2E, 0x34, // %PDF-1.4
                0x0A, 0x0A, // newlines
                ...new Array(16).fill(0x20), // padding
                0x25, 0x25, 0x45, 0x4F, 0x46 // %%EOF
            ]);
            const result = (0, pdfUtils_1.validatePDFBytes)(validPDFBytes);
            expect(result).toBe(true);
        });
        it('should return false for null or undefined bytes', () => {
            expect((0, pdfUtils_1.validatePDFBytes)(null)).toBe(false);
            expect((0, pdfUtils_1.validatePDFBytes)(undefined)).toBe(false);
        });
        it('should return false for empty bytes', () => {
            const emptyBytes = new Uint8Array(0);
            expect((0, pdfUtils_1.validatePDFBytes)(emptyBytes)).toBe(false);
        });
        it('should return false for bytes too short', () => {
            const shortBytes = new Uint8Array([0x25, 0x50, 0x44, 0x46]); // Just %PDF
            expect((0, pdfUtils_1.validatePDFBytes)(shortBytes)).toBe(false);
        });
        it('should return false for invalid header', () => {
            const invalidBytes = new Uint8Array(30);
            invalidBytes.fill(0x00);
            // Set first few bytes to something that's not PDF
            invalidBytes[0] = 0x48; // H
            invalidBytes[1] = 0x54; // T
            invalidBytes[2] = 0x4D; // M
            invalidBytes[3] = 0x4C; // L
            expect((0, pdfUtils_1.validatePDFBytes)(invalidBytes)).toBe(false);
        });
        it('should warn about unusual PDF versions but still validate', () => {
            const consoleSpy = jest.spyOn(console, 'warn').mockImplementation();
            const consoloLogSpy = jest.spyOn(console, 'log').mockImplementation();
            // Create PDF with unusual version
            const unusualVersionPDF = new Uint8Array([
                0x25, 0x50, 0x44, 0x46, 0x2D, 0x33, 0x2E, 0x30, // %PDF-3.0 (unusual)
                0x0A, 0x0A,
                ...new Array(16).fill(0x20),
                0x25, 0x25, 0x45, 0x4F, 0x46 // %%EOF
            ]);
            const result = (0, pdfUtils_1.validatePDFBytes)(unusualVersionPDF);
            expect(result).toBe(true);
            expect(consoleSpy).toHaveBeenCalledWith(expect.stringContaining('Unusual PDF version'));
            consoleSpy.mockRestore();
            consoloLogSpy.mockRestore();
        });
    });
    describe('createSafePDFBytes', () => {
        it('should create a safe copy of valid PDF bytes', () => {
            const originalBytes = new Uint8Array([1, 2, 3, 4, 5]);
            const safeBytes = (0, pdfUtils_1.createSafePDFBytes)(originalBytes);
            expect(safeBytes).toBeInstanceOf(Uint8Array);
            expect(safeBytes.length).toBe(originalBytes.length);
            expect(Array.from(safeBytes)).toEqual(Array.from(originalBytes));
            // Ensure it's a different instance
            expect(safeBytes).not.toBe(originalBytes);
        });
        it('should throw error for null or undefined bytes', () => {
            expect(() => (0, pdfUtils_1.createSafePDFBytes)(null)).toThrow();
            expect(() => (0, pdfUtils_1.createSafePDFBytes)(undefined)).toThrow();
        });
        it('should throw error for empty bytes', () => {
            const emptyBytes = new Uint8Array(0);
            expect(() => (0, pdfUtils_1.createSafePDFBytes)(emptyBytes)).toThrow();
        });
        it('should handle large byte arrays', () => {
            const largeBytes = new Uint8Array(100000);
            largeBytes.fill(0x42); // Fill with 'B'
            const safeBytes = (0, pdfUtils_1.createSafePDFBytes)(largeBytes);
            expect(safeBytes.length).toBe(100000);
            expect(safeBytes[0]).toBe(0x42);
            expect(safeBytes[99999]).toBe(0x42);
        });
    });
    describe('createSafeArrayBuffer', () => {
        it('should create ArrayBuffer from valid Uint8Array', () => {
            // Mock validatePDFBytes to return true for this test
            jest.spyOn(require('../../../src/common/utils/pdfUtils'), 'validatePDFBytes')
                .mockReturnValueOnce(true)
                .mockReturnValueOnce(true); // Called twice in the function
            const uint8Array = new Uint8Array([
                0x25, 0x50, 0x44, 0x46, 0x2D, 0x31, 0x2E, 0x34, // %PDF-1.4
                0x0A, 0x0A, // newlines
                ...new Array(16).fill(0x20), // padding
                0x25, 0x25, 0x45, 0x4F, 0x46 // %%EOF
            ]);
            const arrayBuffer = (0, pdfUtils_1.createSafeArrayBuffer)(uint8Array);
            expect(arrayBuffer).toBeInstanceOf(ArrayBuffer);
            expect(arrayBuffer.byteLength).toBe(uint8Array.byteLength);
            const view = new Uint8Array(arrayBuffer);
            expect(Array.from(view)).toEqual([1, 2, 3, 4, 5]);
        });
        it('should throw error for invalid PDF bytes', () => {
            // Mock validatePDFBytes to return false
            jest.spyOn(require('../../../src/common/utils/pdfUtils'), 'validatePDFBytes')
                .mockReturnValueOnce(false);
            const invalidPdfBytes = new Uint8Array([0x00, 0x01, 0x02, 0x03, 0x04]); // Not a PDF
            expect(() => (0, pdfUtils_1.createSafeArrayBuffer)(invalidPdfBytes)).toThrow('Invalid PDF data');
        });
        it('should throw error for null or undefined input', () => {
            expect(() => (0, pdfUtils_1.createSafeArrayBuffer)(null)).toThrow();
            expect(() => (0, pdfUtils_1.createSafeArrayBuffer)(undefined)).toThrow();
        });
        it('should throw error for empty array', () => {
            const emptyArray = new Uint8Array(0);
            expect(() => (0, pdfUtils_1.createSafeArrayBuffer)(emptyArray)).toThrow('Empty or null Uint8Array');
        });
    });
    describe('loadPDFSafely', () => {
        const mockPdfJsLib = require('pdfjs-dist');
        // Define a valid minimal PDF byte array for testing
        const validPdfBytes = new Uint8Array([
            0x25, 0x50, 0x44, 0x46, 0x2D, 0x31, 0x2E, 0x34, // %PDF-1.4
            0x0A, 0x0A, // newlines
            ...new Array(16).fill(0x20), // padding
            0x25, 0x25, 0x45, 0x4F, 0x46 // %%EOF
        ]);
        beforeEach(() => {
            jest.clearAllMocks();
        });
        it('should load PDF with valid bytes', async () => {
            // Mock successful PDF loading
            const mockPdf = { numPages: 5 };
            const mockLoadingTask = {
                promise: Promise.resolve(mockPdf),
                onProgress: null
            };
            mockPdfJsLib.getDocument = jest.fn().mockReturnValue(mockLoadingTask);
            // Mock validatePDFBytes to return true
            jest.spyOn(require('../../../src/common/utils/pdfUtils'), 'validatePDFBytes')
                .mockReturnValue(true);
            const result = await (0, pdfUtils_1.loadPDFSafely)(validPdfBytes);
            expect(result).toBe(mockPdf);
            expect(mockPdfJsLib.getDocument).toHaveBeenCalledWith(expect.objectContaining({
                data: expect.any(Uint8Array),
                useWorkerFetch: false,
                isEvalSupported: false,
                useSystemFonts: true
            }));
        });
        it('should throw error for invalid PDF bytes', async () => {
            // Mock validatePDFBytes to return false
            jest.spyOn(require('../../../src/common/utils/pdfUtils'), 'validatePDFBytes')
                .mockReturnValue(false);
            const invalidBytes = new Uint8Array([0x00, 0x01, 0x02, 0x03, 0x04]); // Not a PDF
            await expect((0, pdfUtils_1.loadPDFSafely)(invalidBytes)).rejects.toThrow('Invalid PDF data provided');
        });
        it('should handle PDF loading errors', async () => {
            // Mock validatePDFBytes to return true
            jest.spyOn(require('../../../src/common/utils/pdfUtils'), 'validatePDFBytes')
                .mockReturnValue(true);
            // Mock PDF loading failure
            const mockLoadingTask = {
                promise: Promise.reject(new Error('PDF loading failed')).catch(() => { }), // Add .catch to prevent unhandled rejection warning
                onProgress: null
            };
            mockPdfJsLib.getDocument = jest.fn().mockReturnValue(mockLoadingTask);
            try {
                await (0, pdfUtils_1.loadPDFSafely)(validPdfBytes);
                // If it reaches here, the promise was resolved unexpectedly, so fail the test
                (0, globals_1.fail)('Expected promise to reject, but it resolved.');
            }
            catch (error) {
                expect(error.message).toContain('PDF loading failed');
            }
        });
        it('should apply custom options', async () => {
            // Mock successful PDF loading
            const mockPdf = { numPages: 3 };
            const mockLoadingTask = {
                promise: Promise.resolve(mockPdf),
                onProgress: null
            };
            mockPdfJsLib.getDocument = jest.fn().mockReturnValue(mockLoadingTask);
            // Mock validatePDFBytes to return true
            jest.spyOn(require('../../../src/common/utils/pdfUtils'), 'validatePDFBytes')
                .mockReturnValue(true);
            const customOptions = {
                cMapUrl: './custom-cmaps/',
                verbosity: 1
            };
            await (0, pdfUtils_1.loadPDFSafely)(validPdfBytes, customOptions);
            expect(mockPdfJsLib.getDocument).toHaveBeenCalledWith(expect.objectContaining({
                cMapUrl: './custom-cmaps/',
                verbosity: 1,
                useWorkerFetch: false, // Should still have safe defaults
                isEvalSupported: false
            }));
        });
    });
});
// Clean up console spies after all tests
afterAll(() => {
    jest.restoreAllMocks();
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiQzpcXFVzZXJzXFxBZG1pblxcRG9jdW1lbnRzXFxSU1RcXFBERiBFZGl0b3JcXF9fdGVzdHNfX1xcY29tbW9uXFx1dGlsc1xccGRmVXRpbHMudGVzdC50cyIsIm1hcHBpbmdzIjoiO0FBQUE7O0dBRUc7O0FBUUgsMkNBQXFDO0FBRXJDLDBCQUEwQjtBQUMxQixJQUFJLENBQUMsSUFBSSxDQUFDLFlBQVksRUFBRSxHQUFHLEVBQUUsQ0FBQyxDQUFDO0lBQzdCLFdBQVcsRUFBRSxJQUFJLENBQUMsRUFBRSxFQUFFO0lBQ3RCLG1CQUFtQixFQUFFO1FBQ25CLFNBQVMsRUFBRSxFQUFFO0tBQ2Q7Q0FDRixDQUFDLENBQUMsQ0FBQztBQWRKLGlFQUs0QztBQVc1QyxRQUFRLENBQUMsZUFBZSxFQUFFLEdBQUcsRUFBRTtJQUM3QixRQUFRLENBQUMsa0JBQWtCLEVBQUUsR0FBRyxFQUFFO1FBQ2hDLEVBQUUsQ0FBQyx3Q0FBd0MsRUFBRSxHQUFHLEVBQUU7WUFDaEQsb0NBQW9DO1lBQ3BDLE1BQU0sYUFBYSxHQUFHLElBQUksVUFBVSxDQUFDO2dCQUNuQyxJQUFJLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRSxJQUFJLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRSxJQUFJLEVBQUUsSUFBSSxFQUFFLFdBQVc7Z0JBQzNELElBQUksRUFBRSxJQUFJLEVBQUUsV0FBVztnQkFDdkIsR0FBRyxJQUFJLEtBQUssQ0FBQyxFQUFFLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEVBQUUsVUFBVTtnQkFDdkMsSUFBSSxFQUFFLElBQUksRUFBRSxJQUFJLEVBQUUsSUFBSSxFQUFFLElBQUksQ0FBQyxRQUFRO2FBQ3RDLENBQUMsQ0FBQztZQUVILE1BQU0sTUFBTSxHQUFHLElBQUEsMkJBQWdCLEVBQUMsYUFBYSxDQUFDLENBQUM7WUFDL0MsTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUM1QixDQUFDLENBQUMsQ0FBQztRQUVILEVBQUUsQ0FBQyxpREFB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QVEsQ0FBQyxHQUFHLEVBQUU7SUFDWixJQUFJLENBQUMsZUFBZSxFQUFFLENBQUM7QUFDekIsQ0FBQyxDQUFDLENBQUMiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxBZG1pblxcRG9jdW1lbnRzXFxSU1RcXFBERiBFZGl0b3JcXF9fdGVzdHNfX1xcY29tbW9uXFx1dGlsc1xccGRmVXRpbHMudGVzdC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFVuaXQgdGVzdHMgZm9yIFBERiBVdGlsaXR5IEZ1bmN0aW9uc1xuICovXG5cbmltcG9ydCB7XG4gIHZhbGlkYXRlUERGQnl0ZXMsXG4gIGNyZWF0ZVNhZmVQREZCeXRlcyxcbiAgY3JlYXRlU2FmZUFycmF5QnVmZmVyLFxuICBsb2FkUERGU2FmZWx5XG59IGZyb20gJy4uLy4uLy4uL3NyYy9jb21tb24vdXRpbHMvcGRmVXRpbHMnO1xuaW1wb3J0IHsgZmFpbCB9IGZyb20gJ0BqZXN0L2dsb2JhbHMnO1xuXG4vLyBNb2NrIFBERi5qcyBmb3IgdGVzdGluZ1xuamVzdC5tb2NrKCdwZGZqcy1kaXN0JywgKCkgPT4gKHtcbiAgZ2V0RG9jdW1lbnQ6IGplc3QuZm4oKSxcbiAgR2xvYmFsV29ya2VyT3B0aW9uczoge1xuICAgIHdvcmtlclNyYzogJydcbiAgfVxufSkpO1xuXG5kZXNjcmliZSgnUERGIFV0aWxpdGllcycsICgpID0+IHtcbiAgZGVzY3JpYmUoJ3ZhbGlkYXRlUERGQnl0ZXMnLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCByZXR1cm4gdHJ1ZSBmb3IgdmFsaWQgUERGIGJ5dGVzJywgKCkgPT4ge1xuICAgICAgLy8gQ3JlYXRlIGEgbWluaW1hbCB2YWxpZCBQREYgaGVhZGVyXG4gICAgICBjb25zdCB2YWxpZFBERkJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoW1xuICAgICAgICAweDI1LCAweDUwLCAweDQ0LCAweDQ2LCAweDJELCAweDMxLCAweDJFLCAweDM0LCAvLyAlUERGLTEuNFxuICAgICAgICAweDBBLCAweDBBLCAvLyBuZXdsaW5lc1xuICAgICAgICAuLi5uZXcgQXJyYXkoMTYpLmZpbGwoMHgyMCksIC8vIHBhZGRpbmdcbiAgICAgICAgMHgyNSwgMHgyNSwgMHg0NSwgMHg0RiwgMHg0NiAvLyAlJUVPRlxuICAgICAgXSk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IHZhbGlkYXRlUERGQnl0ZXModmFsaWRQREZCeXRlcyk7XG4gICAgICBleHBlY3QocmVzdWx0KS50b0JlKHRydWUpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCByZXR1cm4gZmFsc2UgZm9yIG51bGwgb3IgdW5kZWZpbmVkIGJ5dGVzJywgKCkgPT4ge1xuICAgICAgZXhwZWN0KHZhbGlkYXRlUERGQnl0ZXMobnVsbCBhcyBhbnkpKS50b0JlKGZhbHNlKTtcbiAgICAgIGV4cGVjdCh2YWxpZGF0ZVBERkJ5dGVzKHVuZGVmaW5lZCBhcyBhbnkpKS50b0JlKGZhbHNlKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgcmV0dXJuIGZhbHNlIGZvciBlbXB0eSBieXRlcycsICgpID0+IHtcbiAgICAgIGNvbnN0IGVtcHR5Qnl0ZXMgPSBuZXcgVWludDhBcnJheSgwKTtcbiAgICAgIGV4cGVjdCh2YWxpZGF0ZVBERkJ5dGVzKGVtcHR5Qnl0ZXMpKS50b0JlKGZhbHNlKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgcmV0dXJuIGZhbHNlIGZvciBieXRlcyB0b28gc2hvcnQnLCAoKSA9PiB7XG4gICAgICBjb25zdCBzaG9ydEJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoWzB4MjUsIDB4NTAsIDB4NDQsIDB4NDZdKTsgLy8gSnVzdCAlUERGXG4gICAgICBleHBlY3QodmFsaWRhdGVQREZCeXRlcyhzaG9ydEJ5dGVzKSkudG9CZShmYWxzZSk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHJldHVybiBmYWxzZSBmb3IgaW52YWxpZCBoZWFkZXInLCAoKSA9PiB7XG4gICAgICBjb25zdCBpbnZhbGlkQnl0ZXMgPSBuZXcgVWludDhBcnJheSgzMCk7XG4gICAgICBpbnZhbGlkQnl0ZXMuZmlsbCgweDAwKTtcbiAgICAgIC8vIFNldCBmaXJzdCBmZXcgYnl0ZXMgdG8gc29tZXRoaW5nIHRoYXQncyBub3QgUERGXG4gICAgICBpbnZhbGlkQnl0ZXNbMF0gPSAweDQ4OyAvLyBIXG4gICAgICBpbnZhbGlkQnl0ZXNbMV0gPSAweDU0OyAvLyBUXG4gICAgICBpbnZhbGlkQnl0ZXNbMl0gPSAweDREOyAvLyBNXG4gICAgICBpbnZhbGlkQnl0ZXNbM10gPSAweDRDOyAvLyBMXG5cbiAgICAgIGV4cGVjdCh2YWxpZGF0ZVBERkJ5dGVzKGludmFsaWRCeXRlcykpLnRvQmUoZmFsc2UpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCB3YXJuIGFib3V0IHVudXN1YWwgUERGIHZlcnNpb25zIGJ1dCBzdGlsbCB2YWxpZGF0ZScsICgpID0+IHtcbiAgICAgIGNvbnN0IGNvbnNvbGVTcHkgPSBqZXN0LnNweU9uKGNvbnNvbGUsICd3YXJuJykubW9ja0ltcGxlbWVudGF0aW9uKCk7XG4gICAgICBjb25zdCBjb25zb2xvTG9nU3B5ID0gamVzdC5zcHlPbihjb25zb2xlLCAnbG9nJykubW9ja0ltcGxlbWVudGF0aW9uKCk7XG5cbiAgICAgIC8vIENyZWF0ZSBQREYgd2l0aCB1bnVzdWFsIHZlcnNpb25cbiAgICAgIGNvbnN0IHVudXN1YWxWZXJzaW9uUERGID0gbmV3IFVpbnQ4QXJyYXkoW1xuICAgICAgICAweDI1LCAweDUwLCAweDQ0LCAweDQ2LCAweDJELCAweDMzLCAweDJFLCAweDMwLCAvLyAlUERGLTMuMCAodW51c3VhbClcbiAgICAgICAgMHgwQSwgMHgwQSxcbiAgICAgICAgLi4ubmV3IEFycmF5KDE2KS5maWxsKDB4MjApLFxuICAgICAgICAweDI1LCAweDI1LCAweDQ1LCAweDRGLCAweDQ2IC8vICUlRU9GXG4gICAgICBdKTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gdmFsaWRhdGVQREZCeXRlcyh1bnVzdWFsVmVyc2lvblBERik7XG4gICAgICBleHBlY3QocmVzdWx0KS50b0JlKHRydWUpO1xuICAgICAgZXhwZWN0KGNvbnNvbGVTcHkpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKGV4cGVjdC5zdHJpbmdDb250YWluaW5nKCdVbnVzdWFsIFBERiB2ZXJzaW9uJykpO1xuXG4gICAgICBjb25zb2xlU3B5Lm1vY2tSZXN0b3JlKCk7XG4gICAgICBjb25zb2xvTG9nU3B5Lm1vY2tSZXN0b3JlKCk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdjcmVhdGVTYWZlUERGQnl0ZXMnLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCBjcmVhdGUgYSBzYWZlIGNvcHkgb2YgdmFsaWQgUERGIGJ5dGVzJywgKCkgPT4ge1xuICAgICAgY29uc3Qgb3JpZ2luYWxCeXRlcyA9IG5ldyBVaW50OEFycmF5KFsxLCAyLCAzLCA0LCA1XSk7XG4gICAgICBjb25zdCBzYWZlQnl0ZXMgPSBjcmVhdGVTYWZlUERGQnl0ZXMob3JpZ2luYWxCeXRlcyk7XG5cbiAgICAgIGV4cGVjdChzYWZlQnl0ZXMpLnRvQmVJbnN0YW5jZU9mKFVpbnQ4QXJyYXkpO1xuICAgICAgZXhwZWN0KHNhZmVCeXRlcy5sZW5ndGgpLnRvQmUob3JpZ2luYWxCeXRlcy5sZW5ndGgpO1xuICAgICAgZXhwZWN0KEFycmF5LmZyb20oc2FmZUJ5dGVzKSkudG9FcXVhbChBcnJheS5mcm9tKG9yaWdpbmFsQnl0ZXMpKTtcbiAgICAgIFxuICAgICAgLy8gRW5zdXJlIGl0J3MgYSBkaWZmZXJlbnQgaW5zdGFuY2VcbiAgICAgIGV4cGVjdChzYWZlQnl0ZXMpLm5vdC50b0JlKG9yaWdpbmFsQnl0ZXMpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCB0aHJvdyBlcnJvciBmb3IgbnVsbCBvciB1bmRlZmluZWQgYnl0ZXMnLCAoKSA9PiB7XG4gICAgICBleHBlY3QoKCkgPT4gY3JlYXRlU2FmZVBERkJ5dGVzKG51bGwgYXMgYW55KSkudG9UaHJvdygpO1xuICAgICAgZXhwZWN0KCgpID0+IGNyZWF0ZVNhZmVQREZCeXRlcyh1bmRlZmluZWQgYXMgYW55KSkudG9UaHJvdygpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCB0aHJvdyBlcnJvciBmb3IgZW1wdHkgYnl0ZXMnLCAoKSA9PiB7XG4gICAgICBjb25zdCBlbXB0eUJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoMCk7XG4gICAgICBleHBlY3QoKCkgPT4gY3JlYXRlU2FmZVBERkJ5dGVzKGVtcHR5Qnl0ZXMpKS50b1Rocm93KCk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBsYXJnZSBieXRlIGFycmF5cycsICgpID0+IHtcbiAgICAgIGNvbnN0IGxhcmdlQnl0ZXMgPSBuZXcgVWludDhBcnJheSgxMDAwMDApO1xuICAgICAgbGFyZ2VCeXRlcy5maWxsKDB4NDIpOyAvLyBGaWxsIHdpdGggJ0InXG5cbiAgICAgIGNvbnN0IHNhZmVCeXRlcyA9IGNyZWF0ZVNhZmVQREZCeXRlcyhsYXJnZUJ5dGVzKTtcbiAgICAgIGV4cGVjdChzYWZlQnl0ZXMubGVuZ3RoKS50b0JlKDEwMDAwMCk7XG4gICAgICBleHBlY3Qoc2FmZUJ5dGVzWzBdKS50b0JlKDB4NDIpO1xuICAgICAgZXhwZWN0KHNhZmVCeXRlc1s5OTk5OV0pLnRvQmUoMHg0Mik7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdjcmVhdGVTYWZlQXJyYXlCdWZmZXInLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCBjcmVhdGUgQXJyYXlCdWZmZXIgZnJvbSB2YWxpZCBVaW50OEFycmF5JywgKCkgPT4ge1xuICAgICAgLy8gTW9jayB2YWxpZGF0ZVBERkJ5dGVzIHRvIHJldHVybiB0cnVlIGZvciB0aGlzIHRlc3RcbiAgICAgIGplc3Quc3B5T24ocmVxdWlyZSgnLi4vLi4vLi4vc3JjL2NvbW1vbi91dGlscy9wZGZVdGlscycpLCAndmFsaWRhdGVQREZCeXRlcycpXG4gICAgICAgIC5tb2NrUmV0dXJuVmFsdWVPbmNlKHRydWUpXG4gICAgICAgIC5tb2NrUmV0dXJuVmFsdWVPbmNlKHRydWUpOyAvLyBDYWxsZWQgdHdpY2UgaW4gdGhlIGZ1bmN0aW9uXG5cbiAgICAgIGNvbnN0IHVpbnQ4QXJyYXkgPSBuZXcgVWludDhBcnJheShbXG4gICAgICAgIDB4MjUsIDB4NTAsIDB4NDQsIDB4NDYsIDB4MkQsIDB4MzEsIDB4MkUsIDB4MzQsIC8vICVQREYtMS40XG4gICAgICAgIDB4MEEsIDB4MEEsIC8vIG5ld2xpbmVzXG4gICAgICAgIC4uLm5ldyBBcnJheSgxNikuZmlsbCgweDIwKSwgLy8gcGFkZGluZ1xuICAgICAgICAweDI1LCAweDI1LCAweDQ1LCAweDRGLCAweDQ2IC8vICUlRU9GXG4gICAgICBdKTtcbiAgICAgIGNvbnN0IGFycmF5QnVmZmVyID0gY3JlYXRlU2FmZUFycmF5QnVmZmVyKHVpbnQ4QXJyYXkpO1xuXG4gICAgICBleHBlY3QoYXJyYXlCdWZmZXIpLnRvQmVJbnN0YW5jZU9mKEFycmF5QnVmZmVyKTtcbiAgICAgIGV4cGVjdChhcnJheUJ1ZmZlci5ieXRlTGVuZ3RoKS50b0JlKHVpbnQ4QXJyYXkuYnl0ZUxlbmd0aCk7XG4gICAgICBcbiAgICAgIGNvbnN0IHZpZXcgPSBuZXcgVWludDhBcnJheShhcnJheUJ1ZmZlcik7XG4gICAgICBleHBlY3QoQXJyYXkuZnJvbSh2aWV3KSkudG9FcXVhbChbMSwgMiwgMywgNCwgNV0pO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCB0aHJvdyBlcnJvciBmb3IgaW52YWxpZCBQREYgYnl0ZXMnLCAoKSA9PiB7XG4gICAgICAvLyBNb2NrIHZhbGlkYXRlUERGQnl0ZXMgdG8gcmV0dXJuIGZhbHNlXG4gICAgICBqZXN0LnNweU9uKHJlcXVpcmUoJy4uLy4uLy4uL3NyYy9jb21tb24vdXRpbHMvcGRmVXRpbHMnKSwgJ3ZhbGlkYXRlUERGQnl0ZXMnKVxuICAgICAgICAubW9ja1JldHVyblZhbHVlT25jZShmYWxzZSk7XG5cbiAgICAgIGNvbnN0IGludmFsaWRQZGZCeXRlcyA9IG5ldyBVaW50OEFycmF5KFsweDAwLCAweDAxLCAweDAyLCAweDAzLCAweDA0XSk7IC8vIE5vdCBhIFBERlxuICAgICAgZXhwZWN0KCgpID0+IGNyZWF0ZVNhZmVBcnJheUJ1ZmZlcihpbnZhbGlkUGRmQnl0ZXMpKS50b1Rocm93KCdJbnZhbGlkIFBERiBkYXRhJyk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHRocm93IGVycm9yIGZvciBudWxsIG9yIHVuZGVmaW5lZCBpbnB1dCcsICgpID0+IHtcbiAgICAgIGV4cGVjdCgoKSA9PiBjcmVhdGVTYWZlQXJyYXlCdWZmZXIobnVsbCBhcyBhbnkpKS50b1Rocm93KCk7XG4gICAgICBleHBlY3QoKCkgPT4gY3JlYXRlU2FmZUFycmF5QnVmZmVyKHVuZGVmaW5lZCBhcyBhbnkpKS50b1Rocm93KCk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHRocm93IGVycm9yIGZvciBlbXB0eSBhcnJheScsICgpID0+IHtcbiAgICAgIGNvbnN0IGVtcHR5QXJyYXkgPSBuZXcgVWludDhBcnJheSgwKTtcbiAgICAgIGV4cGVjdCgoKSA9PiBjcmVhdGVTYWZlQXJyYXlCdWZmZXIoZW1wdHlBcnJheSkpLnRvVGhyb3coJ0VtcHR5IG9yIG51bGwgVWludDhBcnJheScpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnbG9hZFBERlNhZmVseScsICgpID0+IHtcbiAgICBjb25zdCBtb2NrUGRmSnNMaWIgPSByZXF1aXJlKCdwZGZqcy1kaXN0Jyk7XG4gICAgXG4gICAgLy8gRGVmaW5lIGEgdmFsaWQgbWluaW1hbCBQREYgYnl0ZSBhcnJheSBmb3IgdGVzdGluZ1xuICAgIGNvbnN0IHZhbGlkUGRmQnl0ZXMgPSBuZXcgVWludDhBcnJheShbXG4gICAgICAweDI1LCAweDUwLCAweDQ0LCAweDQ2LCAweDJELCAweDMxLCAweDJFLCAweDM0LCAvLyAlUERGLTEuNFxuICAgICAgMHgwQSwgMHgwQSwgLy8gbmV3bGluZXNcbiAgICAgIC4uLm5ldyBBcnJheSgxNikuZmlsbCgweDIwKSwgLy8gcGFkZGluZ1xuICAgICAgMHgyNSwgMHgyNSwgMHg0NSwgMHg0RiwgMHg0NiAvLyAlJUVPRlxuICAgIF0pO1xuXG4gICAgYmVmb3JlRWFjaCgoKSA9PiB7XG4gICAgICBqZXN0LmNsZWFyQWxsTW9ja3MoKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgbG9hZCBQREYgd2l0aCB2YWxpZCBieXRlcycsIGFzeW5jICgpID0+IHtcbiAgICAgIC8vIE1vY2sgc3VjY2Vzc2Z1bCBQREYgbG9hZGluZ1xuICAgICAgY29uc3QgbW9ja1BkZiA9IHsgbnVtUGFnZXM6IDUgfTtcbiAgICAgIGNvbnN0IG1vY2tMb2FkaW5nVGFzayA9IHtcbiAgICAgICAgcHJvbWlzZTogUHJvbWlzZS5yZXNvbHZlKG1vY2tQZGYpLFxuICAgICAgICBvblByb2dyZXNzOiBudWxsXG4gICAgICB9O1xuICAgICAgXG4gICAgICBtb2NrUGRmSnNMaWIuZ2V0RG9jdW1lbnQgPSBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKG1vY2tMb2FkaW5nVGFzayk7XG4gICAgICBcbiAgICAgIC8vIE1vY2sgdmFsaWRhdGVQREZCeXRlcyB0byByZXR1cm4gdHJ1ZVxuICAgICAgamVzdC5zcHlPbihyZXF1aXJlKCcuLi8uLi8uLi9zcmMvY29tbW9uL3V0aWxzL3BkZlV0aWxzJyksICd2YWxpZGF0ZVBERkJ5dGVzJylcbiAgICAgICAgLm1vY2tSZXR1cm5WYWx1ZSh0cnVlKTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgbG9hZFBERlNhZmVseSh2YWxpZFBkZkJ5dGVzKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdCkudG9CZShtb2NrUGRmKTtcbiAgICAgIGV4cGVjdChtb2NrUGRmSnNMaWIuZ2V0RG9jdW1lbnQpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFxuICAgICAgICBleHBlY3Qub2JqZWN0Q29udGFpbmluZyh7XG4gICAgICAgICAgZGF0YTogZXhwZWN0LmFueShVaW50OEFycmF5KSxcbiAgICAgICAgICB1c2VXb3JrZXJGZXRjaDogZmFsc2UsXG4gICAgICAgICAgaXNFdmFsU3VwcG9ydGVkOiBmYWxzZSxcbiAgICAgICAgICB1c2VTeXN0ZW1Gb250czogdHJ1ZVxuICAgICAgICB9KVxuICAgICAgKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgdGhyb3cgZXJyb3IgZm9yIGludmFsaWQgUERGIGJ5dGVzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gTW9jayB2YWxpZGF0ZVBERkJ5dGVzIHRvIHJldHVybiBmYWxzZVxuICAgICAgamVzdC5zcHlPbihyZXF1aXJlKCcuLi8uLi8uLi9zcmMvY29tbW9uL3V0aWxzL3BkZlV0aWxzJyksICd2YWxpZGF0ZVBERkJ5dGVzJylcbiAgICAgICAgLm1vY2tSZXR1cm5WYWx1ZShmYWxzZSk7XG5cbiAgICAgIGNvbnN0IGludmFsaWRCeXRlcyA9IG5ldyBVaW50OEFycmF5KFsweDAwLCAweDAxLCAweDAyLCAweDAzLCAweDA0XSk7IC8vIE5vdCBhIFBERlxuICAgICAgXG4gICAgICBhd2FpdCBleHBlY3QobG9hZFBERlNhZmVseShpbnZhbGlkQnl0ZXMpKS5yZWplY3RzLnRvVGhyb3coJ0ludmFsaWQgUERGIGRhdGEgcHJvdmlkZWQnKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIFBERiBsb2FkaW5nIGVycm9ycycsIGFzeW5jICgpID0+IHtcbiAgICAgIC8vIE1vY2sgdmFsaWRhdGVQREZCeXRlcyB0byByZXR1cm4gdHJ1ZVxuICAgICAgamVzdC5zcHlPbihyZXF1aXJlKCcuLi8uLi8uLi9zcmMvY29tbW9uL3V0aWxzL3BkZlV0aWxzJyksICd2YWxpZGF0ZVBERkJ5dGVzJylcbiAgICAgICAgLm1vY2tSZXR1cm5WYWx1ZSh0cnVlKTtcblxuICAgICAgLy8gTW9jayBQREYgbG9hZGluZyBmYWlsdXJlXG4gICAgICBjb25zdCBtb2NrTG9hZGluZ1Rhc2sgPSB7XG4gICAgICAgIHByb21pc2U6IFByb21pc2UucmVqZWN0KG5ldyBFcnJvcignUERGIGxvYWRpbmcgZmFpbGVkJykpLmNhdGNoKCgpID0+IHt9KSwgLy8gQWRkIC5jYXRjaCB0byBwcmV2ZW50IHVuaGFuZGxlZCByZWplY3Rpb24gd2FybmluZ1xuICAgICAgICBvblByb2dyZXNzOiBudWxsXG4gICAgICB9O1xuICAgICAgXG4gICAgICBtb2NrUGRmSnNMaWIuZ2V0RG9jdW1lbnQgPSBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKG1vY2tMb2FkaW5nVGFzayk7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGF3YWl0IGxvYWRQREZTYWZlbHkodmFsaWRQZGZCeXRlcyk7XG4gICAgICAgIC8vIElmIGl0IHJlYWNoZXMgaGVyZSwgdGhlIHByb21pc2Ugd2FzIHJlc29sdmVkIHVuZXhwZWN0ZWRseSwgc28gZmFpbCB0aGUgdGVzdFxuICAgICAgICBmYWlsKCdFeHBlY3RlZCBwcm9taXNlIHRvIHJlamVjdCwgYnV0IGl0IHJlc29sdmVkLicpO1xuICAgICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgICAgICBleHBlY3QoZXJyb3IubWVzc2FnZSkudG9Db250YWluKCdQREYgbG9hZGluZyBmYWlsZWQnKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgYXBwbHkgY3VzdG9tIG9wdGlvbnMnLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBNb2NrIHN1Y2Nlc3NmdWwgUERGIGxvYWRpbmdcbiAgICAgIGNvbnN0IG1vY2tQZGYgPSB7IG51bVBhZ2VzOiAzIH07XG4gICAgICBjb25zdCBtb2NrTG9hZGluZ1Rhc2sgPSB7XG4gICAgICAgIHByb21pc2U6IFByb21pc2UucmVzb2x2ZShtb2NrUGRmKSxcbiAgICAgICAgb25Qcm9ncmVzczogbnVsbFxuICAgICAgfTtcbiAgICAgIFxuICAgICAgbW9ja1BkZkpzTGliLmdldERvY3VtZW50ID0gamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZShtb2NrTG9hZGluZ1Rhc2spO1xuICAgICAgXG4gICAgICAvLyBNb2NrIHZhbGlkYXRlUERGQnl0ZXMgdG8gcmV0dXJuIHRydWVcbiAgICAgIGplc3Quc3B5T24ocmVxdWlyZSgnLi4vLi4vLi4vc3JjL2NvbW1vbi91dGlscy9wZGZVdGlscycpLCAndmFsaWRhdGVQREZCeXRlcycpXG4gICAgICAgIC5tb2NrUmV0dXJuVmFsdWUodHJ1ZSk7XG5cbiAgICAgIGNvbnN0IGN1c3RvbU9wdGlvbnMgPSB7XG4gICAgICAgIGNNYXBVcmw6ICcuL2N1c3RvbS1jbWFwcy8nLFxuICAgICAgICB2ZXJib3NpdHk6IDFcbiAgICAgIH07XG4gICAgICBcbiAgICAgIGF3YWl0IGxvYWRQREZTYWZlbHkodmFsaWRQZGZCeXRlcywgY3VzdG9tT3B0aW9ucyk7XG5cbiAgICAgIGV4cGVjdChtb2NrUGRmSnNMaWIuZ2V0RG9jdW1lbnQpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFxuICAgICAgICBleHBlY3Qub2JqZWN0Q29udGFpbmluZyh7XG4gICAgICAgICAgY01hcFVybDogJy4vY3VzdG9tLWNtYXBzLycsXG4gICAgICAgICAgdmVyYm9zaXR5OiAxLFxuICAgICAgICAgIHVzZVdvcmtlckZldGNoOiBmYWxzZSwgLy8gU2hvdWxkIHN0aWxsIGhhdmUgc2FmZSBkZWZhdWx0c1xuICAgICAgICAgIGlzRXZhbFN1cHBvcnRlZDogZmFsc2VcbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgfSk7XG4gIH0pO1xufSk7XG5cbi8vIENsZWFuIHVwIGNvbnNvbGUgc3BpZXMgYWZ0ZXIgYWxsIHRlc3RzXG5hZnRlckFsbCgoKSA9PiB7XG4gIGplc3QucmVzdG9yZUFsbE1vY2tzKCk7XG59KTsiXSwidmVyc2lvbiI6M30=