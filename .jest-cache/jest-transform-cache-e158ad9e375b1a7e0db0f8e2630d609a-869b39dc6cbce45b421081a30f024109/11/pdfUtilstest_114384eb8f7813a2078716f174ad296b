08bcd33e2d93630e02b05ff328fcb0bf
"use strict";
/**
 * Unit tests for PDF Utility Functions
 */
Object.defineProperty(exports, "__esModule", { value: true });
const globals_1 = require("@jest/globals");
// Mock PDF.js for testing
jest.mock('pdfjs-dist', () => ({
    getDocument: jest.fn(),
    GlobalWorkerOptions: {
        workerSrc: ''
    }
}));
const pdfUtils_1 = require("../../../src/common/utils/pdfUtils");
describe('PDF Utilities', () => {
    describe('validatePDFBytes', () => {
        it('should return true for valid PDF bytes', () => {
            // Create a minimal valid PDF header
            const validPDFBytes = new Uint8Array([
                0x25, 0x50, 0x44, 0x46, 0x2D, 0x31, 0x2E, 0x34, // %PDF-1.4
                0x0A, 0x0A, // newlines
                ...new Array(16).fill(0x20), // padding
                0x25, 0x25, 0x45, 0x4F, 0x46 // %%EOF
            ]);
            const result = (0, pdfUtils_1.validatePDFBytes)(validPDFBytes);
            expect(result).toBe(true);
        });
        it('should return false for null or undefined bytes', () => {
            expect((0, pdfUtils_1.validatePDFBytes)(null)).toBe(false);
            expect((0, pdfUtils_1.validatePDFBytes)(undefined)).toBe(false);
        });
        it('should return false for empty bytes', () => {
            const emptyBytes = new Uint8Array(0);
            expect((0, pdfUtils_1.validatePDFBytes)(emptyBytes)).toBe(false);
        });
        it('should return false for bytes too short', () => {
            const shortBytes = new Uint8Array([0x25, 0x50, 0x44, 0x46]); // Just %PDF
            expect((0, pdfUtils_1.validatePDFBytes)(shortBytes)).toBe(false);
        });
        it('should return false for invalid header', () => {
            const invalidBytes = new Uint8Array(30);
            invalidBytes.fill(0x00);
            // Set first few bytes to something that's not PDF
            invalidBytes[0] = 0x48; // H
            invalidBytes[1] = 0x54; // T
            invalidBytes[2] = 0x4D; // M
            invalidBytes[3] = 0x4C; // L
            expect((0, pdfUtils_1.validatePDFBytes)(invalidBytes)).toBe(false);
        });
        it('should warn about unusual PDF versions but still validate', () => {
            const consoleSpy = jest.spyOn(console, 'warn').mockImplementation();
            const consoloLogSpy = jest.spyOn(console, 'log').mockImplementation();
            // Create PDF with unusual version
            const unusualVersionPDF = new Uint8Array([
                0x25, 0x50, 0x44, 0x46, 0x2D, 0x33, 0x2E, 0x30, // %PDF-3.0 (unusual)
                0x0A, 0x0A,
                ...new Array(16).fill(0x20),
                0x25, 0x25, 0x45, 0x4F, 0x46 // %%EOF
            ]);
            const result = (0, pdfUtils_1.validatePDFBytes)(unusualVersionPDF);
            expect(result).toBe(true);
            expect(consoleSpy).toHaveBeenCalledWith(expect.stringContaining('Unusual PDF version'));
            consoleSpy.mockRestore();
            consoloLogSpy.mockRestore();
        });
    });
    describe('createSafePDFBytes', () => {
        it('should create a safe copy of valid PDF bytes', () => {
            const originalBytes = new Uint8Array([1, 2, 3, 4, 5]);
            const safeBytes = (0, pdfUtils_1.createSafePDFBytes)(originalBytes);
            expect(safeBytes).toBeInstanceOf(Uint8Array);
            expect(safeBytes.length).toBe(originalBytes.length);
            expect(Array.from(safeBytes)).toEqual(Array.from(originalBytes));
            // Ensure it's a different instance
            expect(safeBytes).not.toBe(originalBytes);
        });
        it('should throw error for null or undefined bytes', () => {
            expect(() => (0, pdfUtils_1.createSafePDFBytes)(null)).toThrow();
            expect(() => (0, pdfUtils_1.createSafePDFBytes)(undefined)).toThrow();
        });
        it('should throw error for empty bytes', () => {
            const emptyBytes = new Uint8Array(0);
            expect(() => (0, pdfUtils_1.createSafePDFBytes)(emptyBytes)).toThrow();
        });
        it('should handle large byte arrays', () => {
            const largeBytes = new Uint8Array(100000);
            largeBytes.fill(0x42); // Fill with 'B'
            const safeBytes = (0, pdfUtils_1.createSafePDFBytes)(largeBytes);
            expect(safeBytes.length).toBe(100000);
            expect(safeBytes[0]).toBe(0x42);
            expect(safeBytes[99999]).toBe(0x42);
        });
    });
    describe('createSafeArrayBuffer', () => {
        it('should create ArrayBuffer from valid Uint8Array', () => {
            // Mock validatePDFBytes to return true for this test
            jest.spyOn(require('../../../src/common/utils/pdfUtils'), 'validatePDFBytes')
                .mockReturnValueOnce(true)
                .mockReturnValueOnce(true); // Called twice in the function
            const uint8Array = new Uint8Array([
                0x25, 0x50, 0x44, 0x46, 0x2D, 0x31, 0x2E, 0x34, // %PDF-1.4
                0x0A, 0x0A, // newlines
                ...new Array(16).fill(0x20), // padding
                0x25, 0x25, 0x45, 0x4F, 0x46 // %%EOF
            ]);
            const arrayBuffer = (0, pdfUtils_1.createSafeArrayBuffer)(uint8Array);
            expect(arrayBuffer).toBeInstanceOf(ArrayBuffer);
            expect(arrayBuffer.byteLength).toBe(uint8Array.byteLength);
            const view = new Uint8Array(arrayBuffer);
            expect(Array.from(view)).toEqual(Array.from(uint8Array));
        });
        it('should throw error for invalid PDF bytes', () => {
            // Mock validatePDFBytes to return false
            jest.spyOn(require('../../../src/common/utils/pdfUtils'), 'validatePDFBytes')
                .mockReturnValueOnce(false);
            const invalidPdfBytes = new Uint8Array([0x00, 0x01, 0x02, 0x03, 0x04]); // Not a PDF
            expect(() => (0, pdfUtils_1.createSafeArrayBuffer)(invalidPdfBytes)).toThrow('Invalid PDF data');
        });
        it('should throw error for null or undefined input', () => {
            expect(() => (0, pdfUtils_1.createSafeArrayBuffer)(null)).toThrow();
            expect(() => (0, pdfUtils_1.createSafeArrayBuffer)(undefined)).toThrow();
        });
        it('should throw error for empty array', () => {
            const emptyArray = new Uint8Array(0);
            expect(() => (0, pdfUtils_1.createSafeArrayBuffer)(emptyArray)).toThrow('Empty or null Uint8Array');
        });
    });
    describe('loadPDFSafely', () => {
        const mockPdfJsLib = require('pdfjs-dist');
        // Define a valid minimal PDF byte array for testing
        const validPdfBytes = new Uint8Array([
            0x25, 0x50, 0x44, 0x46, 0x2D, 0x31, 0x2E, 0x34, // %PDF-1.4
            0x0A, 0x0A, // newlines
            ...new Array(16).fill(0x20), // padding
            0x25, 0x25, 0x45, 0x4F, 0x46 // %%EOF
        ]);
        beforeEach(() => {
            jest.clearAllMocks();
        });
        it('should load PDF with valid bytes', async () => {
            // Mock successful PDF loading
            const mockPdf = { numPages: 5 };
            const mockLoadingTask = {
                promise: Promise.resolve(mockPdf),
                onProgress: null
            };
            mockPdfJsLib.getDocument = jest.fn().mockReturnValue(mockLoadingTask);
            // Mock validatePDFBytes to return true
            jest.spyOn(require('../../../src/common/utils/pdfUtils'), 'validatePDFBytes')
                .mockReturnValue(true);
            const result = await (0, pdfUtils_1.loadPDFSafely)(validPdfBytes);
            expect(result).toBe(mockPdf);
            expect(mockPdfJsLib.getDocument).toHaveBeenCalledWith(expect.objectContaining({
                data: expect.any(Uint8Array),
                useWorkerFetch: false,
                isEvalSupported: false,
                useSystemFonts: true
            }));
        });
        it('should throw error for invalid PDF bytes', async () => {
            // Mock validatePDFBytes to return false
            jest.spyOn(require('../../../src/common/utils/pdfUtils'), 'validatePDFBytes')
                .mockReturnValue(false);
            const invalidBytes = new Uint8Array([0x00, 0x01, 0x02, 0x03, 0x04]); // Not a PDF
            await expect((0, pdfUtils_1.loadPDFSafely)(invalidBytes)).rejects.toThrow('Invalid PDF data provided');
        });
        it('should handle PDF loading errors', async () => {
            // Mock validatePDFBytes to return true
            jest.spyOn(require('../../../src/common/utils/pdfUtils'), 'validatePDFBytes')
                .mockReturnValue(true);
            // Mock PDF loading failure
            const mockLoadingTask = {
                promise: Promise.reject(new Error('PDF loading failed')).catch(() => { }), // Add .catch to prevent unhandled rejection warning
                onProgress: null
            };
            mockPdfJsLib.getDocument = jest.fn().mockReturnValue(mockLoadingTask);
            try {
                await (0, pdfUtils_1.loadPDFSafely)(validPdfBytes);
                // If it reaches here, the promise was resolved unexpectedly, so fail the test
                (0, globals_1.fail)('Expected promise to reject, but it resolved.');
            }
            catch (error) {
                expect(error.message).toContain('PDF loading failed');
            }
        });
        it('should apply custom options', async () => {
            // Mock successful PDF loading
            const mockPdf = { numPages: 3 };
            const mockLoadingTask = {
                promise: Promise.resolve(mockPdf),
                onProgress: null
            };
            mockPdfJsLib.getDocument = jest.fn().mockReturnValue(mockLoadingTask);
            // Mock validatePDFBytes to return true
            jest.spyOn(require('../../../src/common/utils/pdfUtils'), 'validatePDFBytes')
                .mockReturnValue(true);
            const customOptions = {
                cMapUrl: './custom-cmaps/',
                verbosity: 1
            };
            await (0, pdfUtils_1.loadPDFSafely)(validPdfBytes, customOptions);
            expect(mockPdfJsLib.getDocument).toHaveBeenCalledWith(expect.objectContaining({
                cMapUrl: './custom-cmaps/',
                verbosity: 1,
                useWorkerFetch: false, // Should still have safe defaults
                isEvalSupported: false
            }));
        });
    });
});
// Clean up console spies after all tests
afterAll(() => {
    jest.restoreAllMocks();
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiQzpcXFVzZXJzXFxBZG1pblxcRG9jdW1lbnRzXFxSU1RcXFBERiBFZGl0b3JcXF9fdGVzdHNfX1xcY29tbW9uXFx1dGlsc1xccGRmVXRpbHMudGVzdC50cyIsIm1hcHBpbmdzIjoiO0FBQUE7O0dBRUc7O0FBUUgsMkNBQXFDO0FBRXJDLDBCQUEwQjtBQUMxQixJQUFJLENBQUMsSUFBSSxDQUFDLFlBQVksRUFBRSxHQUFHLEVBQUUsQ0FBQyxDQUFDO0lBQzdCLFdBQVcsRUFBRSxJQUFJLENBQUMsRUFBRSxFQUFFO0lBQ3RCLG1CQUFtQixFQUFFO1FBQ25CLFNBQVMsRUFBRSxFQUFFO0tBQ2Q7Q0FDRixDQUFDLENBQUMsQ0FBQztBQWRKLGlFQUs0QztBQVc1QyxRQUFRLENBQUMsZUFBZSxFQUFFLEdBQUcsRUFBRTtJQUM3QixRQUFRLENBQUMsa0JBQWtCLEVBQUUsR0FBRyxFQUFFO1FBQ2hDLEVBQUUsQ0FBQyx3Q0FBd0MsRUFBRSxHQUFHLEVBQUU7WUFDaEQsb0NBQW9DO1lBQ3BDLE1BQU0sYUFBYSxHQUFHLElBQUksVUFBVSxDQUFDO2dCQUNuQyxJQUFJLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRSxJQUFJLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRSxJQUFJLEVBQUUsSUFBSSxFQUFFLFdBQVc7Z0JBQzNELElBQUksRUFBRSxJQUFJLEVBQUUsV0FBVztnQkFDdkIsR0FBRyxJQUFJLEtBQUssQ0FBQyxFQUFFLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEVBQUUsVUFBVTtnQkFDdkMsSUFBSSxFQUFFLElBQUksRUFBRSxJQUFJLEVBQUUsSUFBSSxFQUFFLElBQUksQ0FBQyxRQUFRO2FBQ3RDLENBQUMsQ0FBQztZQUVILE1BQU0sTUFBTSxHQUFHLElBQUEsMkJBQWdCLEVBQUMsYUFBYSxDQUFDLENBQUM7WUFDL0MsTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUM1QixDQUFDLENBQUMsQ0FBQztRQUVILEVBQUUsQ0FBQyxpREFB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QUksQ0FBQyxlQUFlLEVBQUUsQ0FBQztBQUN6QixDQUFDLENBQUMsQ0FBQyIsIm5hbWVzIjpbXSwic291cmNlcyI6WyJDOlxcVXNlcnNcXEFkbWluXFxEb2N1bWVudHNcXFJTVFxcUERGIEVkaXRvclxcX190ZXN0c19fXFxjb21tb25cXHV0aWxzXFxwZGZVdGlscy50ZXN0LnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogVW5pdCB0ZXN0cyBmb3IgUERGIFV0aWxpdHkgRnVuY3Rpb25zXG4gKi9cblxuaW1wb3J0IHtcbiAgdmFsaWRhdGVQREZCeXRlcyxcbiAgY3JlYXRlU2FmZVBERkJ5dGVzLFxuICBjcmVhdGVTYWZlQXJyYXlCdWZmZXIsXG4gIGxvYWRQREZTYWZlbHlcbn0gZnJvbSAnLi4vLi4vLi4vc3JjL2NvbW1vbi91dGlscy9wZGZVdGlscyc7XG5pbXBvcnQgeyBmYWlsIH0gZnJvbSAnQGplc3QvZ2xvYmFscyc7XG5cbi8vIE1vY2sgUERGLmpzIGZvciB0ZXN0aW5nXG5qZXN0Lm1vY2soJ3BkZmpzLWRpc3QnLCAoKSA9PiAoe1xuICBnZXREb2N1bWVudDogamVzdC5mbigpLFxuICBHbG9iYWxXb3JrZXJPcHRpb25zOiB7XG4gICAgd29ya2VyU3JjOiAnJ1xuICB9XG59KSk7XG5cbmRlc2NyaWJlKCdQREYgVXRpbGl0aWVzJywgKCkgPT4ge1xuICBkZXNjcmliZSgndmFsaWRhdGVQREZCeXRlcycsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIHJldHVybiB0cnVlIGZvciB2YWxpZCBQREYgYnl0ZXMnLCAoKSA9PiB7XG4gICAgICAvLyBDcmVhdGUgYSBtaW5pbWFsIHZhbGlkIFBERiBoZWFkZXJcbiAgICAgIGNvbnN0IHZhbGlkUERGQnl0ZXMgPSBuZXcgVWludDhBcnJheShbXG4gICAgICAgIDB4MjUsIDB4NTAsIDB4NDQsIDB4NDYsIDB4MkQsIDB4MzEsIDB4MkUsIDB4MzQsIC8vICVQREYtMS40XG4gICAgICAgIDB4MEEsIDB4MEEsIC8vIG5ld2xpbmVzXG4gICAgICAgIC4uLm5ldyBBcnJheSgxNikuZmlsbCgweDIwKSwgLy8gcGFkZGluZ1xuICAgICAgICAweDI1LCAweDI1LCAweDQ1LCAweDRGLCAweDQ2IC8vICUlRU9GXG4gICAgICBdKTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gdmFsaWRhdGVQREZCeXRlcyh2YWxpZFBERkJ5dGVzKTtcbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvQmUodHJ1ZSk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHJldHVybiBmYWxzZSBmb3IgbnVsbCBvciB1bmRlZmluZWQgYnl0ZXMnLCAoKSA9PiB7XG4gICAgICBleHBlY3QodmFsaWRhdGVQREZCeXRlcyhudWxsIGFzIGFueSkpLnRvQmUoZmFsc2UpO1xuICAgICAgZXhwZWN0KHZhbGlkYXRlUERGQnl0ZXModW5kZWZpbmVkIGFzIGFueSkpLnRvQmUoZmFsc2UpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCByZXR1cm4gZmFsc2UgZm9yIGVtcHR5IGJ5dGVzJywgKCkgPT4ge1xuICAgICAgY29uc3QgZW1wdHlCeXRlcyA9IG5ldyBVaW50OEFycmF5KDApO1xuICAgICAgZXhwZWN0KHZhbGlkYXRlUERGQnl0ZXMoZW1wdHlCeXRlcykpLnRvQmUoZmFsc2UpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCByZXR1cm4gZmFsc2UgZm9yIGJ5dGVzIHRvbyBzaG9ydCcsICgpID0+IHtcbiAgICAgIGNvbnN0IHNob3J0Qnl0ZXMgPSBuZXcgVWludDhBcnJheShbMHgyNSwgMHg1MCwgMHg0NCwgMHg0Nl0pOyAvLyBKdXN0ICVQREZcbiAgICAgIGV4cGVjdCh2YWxpZGF0ZVBERkJ5dGVzKHNob3J0Qnl0ZXMpKS50b0JlKGZhbHNlKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgcmV0dXJuIGZhbHNlIGZvciBpbnZhbGlkIGhlYWRlcicsICgpID0+IHtcbiAgICAgIGNvbnN0IGludmFsaWRCeXRlcyA9IG5ldyBVaW50OEFycmF5KDMwKTtcbiAgICAgIGludmFsaWRCeXRlcy5maWxsKDB4MDApO1xuICAgICAgLy8gU2V0IGZpcnN0IGZldyBieXRlcyB0byBzb21ldGhpbmcgdGhhdCdzIG5vdCBQREZcbiAgICAgIGludmFsaWRCeXRlc1swXSA9IDB4NDg7IC8vIEhcbiAgICAgIGludmFsaWRCeXRlc1sxXSA9IDB4NTQ7IC8vIFRcbiAgICAgIGludmFsaWRCeXRlc1syXSA9IDB4NEQ7IC8vIE1cbiAgICAgIGludmFsaWRCeXRlc1szXSA9IDB4NEM7IC8vIExcblxuICAgICAgZXhwZWN0KHZhbGlkYXRlUERGQnl0ZXMoaW52YWxpZEJ5dGVzKSkudG9CZShmYWxzZSk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHdhcm4gYWJvdXQgdW51c3VhbCBQREYgdmVyc2lvbnMgYnV0IHN0aWxsIHZhbGlkYXRlJywgKCkgPT4ge1xuICAgICAgY29uc3QgY29uc29sZVNweSA9IGplc3Quc3B5T24oY29uc29sZSwgJ3dhcm4nKS5tb2NrSW1wbGVtZW50YXRpb24oKTtcbiAgICAgIGNvbnN0IGNvbnNvbG9Mb2dTcHkgPSBqZXN0LnNweU9uKGNvbnNvbGUsICdsb2cnKS5tb2NrSW1wbGVtZW50YXRpb24oKTtcblxuICAgICAgLy8gQ3JlYXRlIFBERiB3aXRoIHVudXN1YWwgdmVyc2lvblxuICAgICAgY29uc3QgdW51c3VhbFZlcnNpb25QREYgPSBuZXcgVWludDhBcnJheShbXG4gICAgICAgIDB4MjUsIDB4NTAsIDB4NDQsIDB4NDYsIDB4MkQsIDB4MzMsIDB4MkUsIDB4MzAsIC8vICVQREYtMy4wICh1bnVzdWFsKVxuICAgICAgICAweDBBLCAweDBBLFxuICAgICAgICAuLi5uZXcgQXJyYXkoMTYpLmZpbGwoMHgyMCksXG4gICAgICAgIDB4MjUsIDB4MjUsIDB4NDUsIDB4NEYsIDB4NDYgLy8gJSVFT0ZcbiAgICAgIF0pO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSB2YWxpZGF0ZVBERkJ5dGVzKHVudXN1YWxWZXJzaW9uUERGKTtcbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvQmUodHJ1ZSk7XG4gICAgICBleHBlY3QoY29uc29sZVNweSkudG9IYXZlQmVlbkNhbGxlZFdpdGgoZXhwZWN0LnN0cmluZ0NvbnRhaW5pbmcoJ1VudXN1YWwgUERGIHZlcnNpb24nKSk7XG5cbiAgICAgIGNvbnNvbGVTcHkubW9ja1Jlc3RvcmUoKTtcbiAgICAgIGNvbnNvbG9Mb2dTcHkubW9ja1Jlc3RvcmUoKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ2NyZWF0ZVNhZmVQREZCeXRlcycsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIGNyZWF0ZSBhIHNhZmUgY29weSBvZiB2YWxpZCBQREYgYnl0ZXMnLCAoKSA9PiB7XG4gICAgICBjb25zdCBvcmlnaW5hbEJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoWzEsIDIsIDMsIDQsIDVdKTtcbiAgICAgIGNvbnN0IHNhZmVCeXRlcyA9IGNyZWF0ZVNhZmVQREZCeXRlcyhvcmlnaW5hbEJ5dGVzKTtcblxuICAgICAgZXhwZWN0KHNhZmVCeXRlcykudG9CZUluc3RhbmNlT2YoVWludDhBcnJheSk7XG4gICAgICBleHBlY3Qoc2FmZUJ5dGVzLmxlbmd0aCkudG9CZShvcmlnaW5hbEJ5dGVzLmxlbmd0aCk7XG4gICAgICBleHBlY3QoQXJyYXkuZnJvbShzYWZlQnl0ZXMpKS50b0VxdWFsKEFycmF5LmZyb20ob3JpZ2luYWxCeXRlcykpO1xuICAgICAgXG4gICAgICAvLyBFbnN1cmUgaXQncyBhIGRpZmZlcmVudCBpbnN0YW5jZVxuICAgICAgZXhwZWN0KHNhZmVCeXRlcykubm90LnRvQmUob3JpZ2luYWxCeXRlcyk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHRocm93IGVycm9yIGZvciBudWxsIG9yIHVuZGVmaW5lZCBieXRlcycsICgpID0+IHtcbiAgICAgIGV4cGVjdCgoKSA9PiBjcmVhdGVTYWZlUERGQnl0ZXMobnVsbCBhcyBhbnkpKS50b1Rocm93KCk7XG4gICAgICBleHBlY3QoKCkgPT4gY3JlYXRlU2FmZVBERkJ5dGVzKHVuZGVmaW5lZCBhcyBhbnkpKS50b1Rocm93KCk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHRocm93IGVycm9yIGZvciBlbXB0eSBieXRlcycsICgpID0+IHtcbiAgICAgIGNvbnN0IGVtcHR5Qnl0ZXMgPSBuZXcgVWludDhBcnJheSgwKTtcbiAgICAgIGV4cGVjdCgoKSA9PiBjcmVhdGVTYWZlUERGQnl0ZXMoZW1wdHlCeXRlcykpLnRvVGhyb3coKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIGxhcmdlIGJ5dGUgYXJyYXlzJywgKCkgPT4ge1xuICAgICAgY29uc3QgbGFyZ2VCeXRlcyA9IG5ldyBVaW50OEFycmF5KDEwMDAwMCk7XG4gICAgICBsYXJnZUJ5dGVzLmZpbGwoMHg0Mik7IC8vIEZpbGwgd2l0aCAnQidcblxuICAgICAgY29uc3Qgc2FmZUJ5dGVzID0gY3JlYXRlU2FmZVBERkJ5dGVzKGxhcmdlQnl0ZXMpO1xuICAgICAgZXhwZWN0KHNhZmVCeXRlcy5sZW5ndGgpLnRvQmUoMTAwMDAwKTtcbiAgICAgIGV4cGVjdChzYWZlQnl0ZXNbMF0pLnRvQmUoMHg0Mik7XG4gICAgICBleHBlY3Qoc2FmZUJ5dGVzWzk5OTk5XSkudG9CZSgweDQyKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ2NyZWF0ZVNhZmVBcnJheUJ1ZmZlcicsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIGNyZWF0ZSBBcnJheUJ1ZmZlciBmcm9tIHZhbGlkIFVpbnQ4QXJyYXknLCAoKSA9PiB7XG4gICAgICAvLyBNb2NrIHZhbGlkYXRlUERGQnl0ZXMgdG8gcmV0dXJuIHRydWUgZm9yIHRoaXMgdGVzdFxuICAgICAgamVzdC5zcHlPbihyZXF1aXJlKCcuLi8uLi8uLi9zcmMvY29tbW9uL3V0aWxzL3BkZlV0aWxzJyksICd2YWxpZGF0ZVBERkJ5dGVzJylcbiAgICAgICAgLm1vY2tSZXR1cm5WYWx1ZU9uY2UodHJ1ZSlcbiAgICAgICAgLm1vY2tSZXR1cm5WYWx1ZU9uY2UodHJ1ZSk7IC8vIENhbGxlZCB0d2ljZSBpbiB0aGUgZnVuY3Rpb25cblxuICAgICAgY29uc3QgdWludDhBcnJheSA9IG5ldyBVaW50OEFycmF5KFtcbiAgICAgICAgMHgyNSwgMHg1MCwgMHg0NCwgMHg0NiwgMHgyRCwgMHgzMSwgMHgyRSwgMHgzNCwgLy8gJVBERi0xLjRcbiAgICAgICAgMHgwQSwgMHgwQSwgLy8gbmV3bGluZXNcbiAgICAgICAgLi4ubmV3IEFycmF5KDE2KS5maWxsKDB4MjApLCAvLyBwYWRkaW5nXG4gICAgICAgIDB4MjUsIDB4MjUsIDB4NDUsIDB4NEYsIDB4NDYgLy8gJSVFT0ZcbiAgICAgIF0pO1xuICAgICAgY29uc3QgYXJyYXlCdWZmZXIgPSBjcmVhdGVTYWZlQXJyYXlCdWZmZXIodWludDhBcnJheSk7XG5cbiAgICAgIGV4cGVjdChhcnJheUJ1ZmZlcikudG9CZUluc3RhbmNlT2YoQXJyYXlCdWZmZXIpO1xuICAgICAgZXhwZWN0KGFycmF5QnVmZmVyLmJ5dGVMZW5ndGgpLnRvQmUodWludDhBcnJheS5ieXRlTGVuZ3RoKTtcbiAgICAgIFxuICAgICAgY29uc3QgdmlldyA9IG5ldyBVaW50OEFycmF5KGFycmF5QnVmZmVyKTtcbiAgICAgIGV4cGVjdChBcnJheS5mcm9tKHZpZXcpKS50b0VxdWFsKEFycmF5LmZyb20odWludDhBcnJheSkpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCB0aHJvdyBlcnJvciBmb3IgaW52YWxpZCBQREYgYnl0ZXMnLCAoKSA9PiB7XG4gICAgICAvLyBNb2NrIHZhbGlkYXRlUERGQnl0ZXMgdG8gcmV0dXJuIGZhbHNlXG4gICAgICBqZXN0LnNweU9uKHJlcXVpcmUoJy4uLy4uLy4uL3NyYy9jb21tb24vdXRpbHMvcGRmVXRpbHMnKSwgJ3ZhbGlkYXRlUERGQnl0ZXMnKVxuICAgICAgICAubW9ja1JldHVyblZhbHVlT25jZShmYWxzZSk7XG5cbiAgICAgIGNvbnN0IGludmFsaWRQZGZCeXRlcyA9IG5ldyBVaW50OEFycmF5KFsweDAwLCAweDAxLCAweDAyLCAweDAzLCAweDA0XSk7IC8vIE5vdCBhIFBERlxuICAgICAgZXhwZWN0KCgpID0+IGNyZWF0ZVNhZmVBcnJheUJ1ZmZlcihpbnZhbGlkUGRmQnl0ZXMpKS50b1Rocm93KCdJbnZhbGlkIFBERiBkYXRhJyk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHRocm93IGVycm9yIGZvciBudWxsIG9yIHVuZGVmaW5lZCBpbnB1dCcsICgpID0+IHtcbiAgICAgIGV4cGVjdCgoKSA9PiBjcmVhdGVTYWZlQXJyYXlCdWZmZXIobnVsbCBhcyBhbnkpKS50b1Rocm93KCk7XG4gICAgICBleHBlY3QoKCkgPT4gY3JlYXRlU2FmZUFycmF5QnVmZmVyKHVuZGVmaW5lZCBhcyBhbnkpKS50b1Rocm93KCk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHRocm93IGVycm9yIGZvciBlbXB0eSBhcnJheScsICgpID0+IHtcbiAgICAgIGNvbnN0IGVtcHR5QXJyYXkgPSBuZXcgVWludDhBcnJheSgwKTtcbiAgICAgIGV4cGVjdCgoKSA9PiBjcmVhdGVTYWZlQXJyYXlCdWZmZXIoZW1wdHlBcnJheSkpLnRvVGhyb3coJ0VtcHR5IG9yIG51bGwgVWludDhBcnJheScpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnbG9hZFBERlNhZmVseScsICgpID0+IHtcbiAgICBjb25zdCBtb2NrUGRmSnNMaWIgPSByZXF1aXJlKCdwZGZqcy1kaXN0Jyk7XG4gICAgXG4gICAgLy8gRGVmaW5lIGEgdmFsaWQgbWluaW1hbCBQREYgYnl0ZSBhcnJheSBmb3IgdGVzdGluZ1xuICAgIGNvbnN0IHZhbGlkUGRmQnl0ZXMgPSBuZXcgVWludDhBcnJheShbXG4gICAgICAweDI1LCAweDUwLCAweDQ0LCAweDQ2LCAweDJELCAweDMxLCAweDJFLCAweDM0LCAvLyAlUERGLTEuNFxuICAgICAgMHgwQSwgMHgwQSwgLy8gbmV3bGluZXNcbiAgICAgIC4uLm5ldyBBcnJheSgxNikuZmlsbCgweDIwKSwgLy8gcGFkZGluZ1xuICAgICAgMHgyNSwgMHgyNSwgMHg0NSwgMHg0RiwgMHg0NiAvLyAlJUVPRlxuICAgIF0pO1xuXG4gICAgYmVmb3JlRWFjaCgoKSA9PiB7XG4gICAgICBqZXN0LmNsZWFyQWxsTW9ja3MoKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgbG9hZCBQREYgd2l0aCB2YWxpZCBieXRlcycsIGFzeW5jICgpID0+IHtcbiAgICAgIC8vIE1vY2sgc3VjY2Vzc2Z1bCBQREYgbG9hZGluZ1xuICAgICAgY29uc3QgbW9ja1BkZiA9IHsgbnVtUGFnZXM6IDUgfTtcbiAgICAgIGNvbnN0IG1vY2tMb2FkaW5nVGFzayA9IHtcbiAgICAgICAgcHJvbWlzZTogUHJvbWlzZS5yZXNvbHZlKG1vY2tQZGYpLFxuICAgICAgICBvblByb2dyZXNzOiBudWxsXG4gICAgICB9O1xuICAgICAgXG4gICAgICBtb2NrUGRmSnNMaWIuZ2V0RG9jdW1lbnQgPSBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKG1vY2tMb2FkaW5nVGFzayk7XG4gICAgICBcbiAgICAgIC8vIE1vY2sgdmFsaWRhdGVQREZCeXRlcyB0byByZXR1cm4gdHJ1ZVxuICAgICAgamVzdC5zcHlPbihyZXF1aXJlKCcuLi8uLi8uLi9zcmMvY29tbW9uL3V0aWxzL3BkZlV0aWxzJyksICd2YWxpZGF0ZVBERkJ5dGVzJylcbiAgICAgICAgLm1vY2tSZXR1cm5WYWx1ZSh0cnVlKTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgbG9hZFBERlNhZmVseSh2YWxpZFBkZkJ5dGVzKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdCkudG9CZShtb2NrUGRmKTtcbiAgICAgIGV4cGVjdChtb2NrUGRmSnNMaWIuZ2V0RG9jdW1lbnQpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFxuICAgICAgICBleHBlY3Qub2JqZWN0Q29udGFpbmluZyh7XG4gICAgICAgICAgZGF0YTogZXhwZWN0LmFueShVaW50OEFycmF5KSxcbiAgICAgICAgICB1c2VXb3JrZXJGZXRjaDogZmFsc2UsXG4gICAgICAgICAgaXNFdmFsU3VwcG9ydGVkOiBmYWxzZSxcbiAgICAgICAgICB1c2VTeXN0ZW1Gb250czogdHJ1ZVxuICAgICAgICB9KVxuICAgICAgKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgdGhyb3cgZXJyb3IgZm9yIGludmFsaWQgUERGIGJ5dGVzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gTW9jayB2YWxpZGF0ZVBERkJ5dGVzIHRvIHJldHVybiBmYWxzZVxuICAgICAgamVzdC5zcHlPbihyZXF1aXJlKCcuLi8uLi8uLi9zcmMvY29tbW9uL3V0aWxzL3BkZlV0aWxzJyksICd2YWxpZGF0ZVBERkJ5dGVzJylcbiAgICAgICAgLm1vY2tSZXR1cm5WYWx1ZShmYWxzZSk7XG5cbiAgICAgIGNvbnN0IGludmFsaWRCeXRlcyA9IG5ldyBVaW50OEFycmF5KFsweDAwLCAweDAxLCAweDAyLCAweDAzLCAweDA0XSk7IC8vIE5vdCBhIFBERlxuICAgICAgXG4gICAgICBhd2FpdCBleHBlY3QobG9hZFBERlNhZmVseShpbnZhbGlkQnl0ZXMpKS5yZWplY3RzLnRvVGhyb3coJ0ludmFsaWQgUERGIGRhdGEgcHJvdmlkZWQnKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIFBERiBsb2FkaW5nIGVycm9ycycsIGFzeW5jICgpID0+IHtcbiAgICAgIC8vIE1vY2sgdmFsaWRhdGVQREZCeXRlcyB0byByZXR1cm4gdHJ1ZVxuICAgICAgamVzdC5zcHlPbihyZXF1aXJlKCcuLi8uLi8uLi9zcmMvY29tbW9uL3V0aWxzL3BkZlV0aWxzJyksICd2YWxpZGF0ZVBERkJ5dGVzJylcbiAgICAgICAgLm1vY2tSZXR1cm5WYWx1ZSh0cnVlKTtcblxuICAgICAgLy8gTW9jayBQREYgbG9hZGluZyBmYWlsdXJlXG4gICAgICBjb25zdCBtb2NrTG9hZGluZ1Rhc2sgPSB7XG4gICAgICAgIHByb21pc2U6IFByb21pc2UucmVqZWN0KG5ldyBFcnJvcignUERGIGxvYWRpbmcgZmFpbGVkJykpLmNhdGNoKCgpID0+IHt9KSwgLy8gQWRkIC5jYXRjaCB0byBwcmV2ZW50IHVuaGFuZGxlZCByZWplY3Rpb24gd2FybmluZ1xuICAgICAgICBvblByb2dyZXNzOiBudWxsXG4gICAgICB9O1xuICAgICAgXG4gICAgICBtb2NrUGRmSnNMaWIuZ2V0RG9jdW1lbnQgPSBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKG1vY2tMb2FkaW5nVGFzayk7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGF3YWl0IGxvYWRQREZTYWZlbHkodmFsaWRQZGZCeXRlcyk7XG4gICAgICAgIC8vIElmIGl0IHJlYWNoZXMgaGVyZSwgdGhlIHByb21pc2Ugd2FzIHJlc29sdmVkIHVuZXhwZWN0ZWRseSwgc28gZmFpbCB0aGUgdGVzdFxuICAgICAgICBmYWlsKCdFeHBlY3RlZCBwcm9taXNlIHRvIHJlamVjdCwgYnV0IGl0IHJlc29sdmVkLicpO1xuICAgICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgICAgICBleHBlY3QoZXJyb3IubWVzc2FnZSkudG9Db250YWluKCdQREYgbG9hZGluZyBmYWlsZWQnKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgYXBwbHkgY3VzdG9tIG9wdGlvbnMnLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBNb2NrIHN1Y2Nlc3NmdWwgUERGIGxvYWRpbmdcbiAgICAgIGNvbnN0IG1vY2tQZGYgPSB7IG51bVBhZ2VzOiAzIH07XG4gICAgICBjb25zdCBtb2NrTG9hZGluZ1Rhc2sgPSB7XG4gICAgICAgIHByb21pc2U6IFByb21pc2UucmVzb2x2ZShtb2NrUGRmKSxcbiAgICAgICAgb25Qcm9ncmVzczogbnVsbFxuICAgICAgfTtcbiAgICAgIFxuICAgICAgbW9ja1BkZkpzTGliLmdldERvY3VtZW50ID0gamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZShtb2NrTG9hZGluZ1Rhc2spO1xuICAgICAgXG4gICAgICAvLyBNb2NrIHZhbGlkYXRlUERGQnl0ZXMgdG8gcmV0dXJuIHRydWVcbiAgICAgIGplc3Quc3B5T24ocmVxdWlyZSgnLi4vLi4vLi4vc3JjL2NvbW1vbi91dGlscy9wZGZVdGlscycpLCAndmFsaWRhdGVQREZCeXRlcycpXG4gICAgICAgIC5tb2NrUmV0dXJuVmFsdWUodHJ1ZSk7XG5cbiAgICAgIGNvbnN0IGN1c3RvbU9wdGlvbnMgPSB7XG4gICAgICAgIGNNYXBVcmw6ICcuL2N1c3RvbS1jbWFwcy8nLFxuICAgICAgICB2ZXJib3NpdHk6IDFcbiAgICAgIH07XG4gICAgICBcbiAgICAgIGF3YWl0IGxvYWRQREZTYWZlbHkodmFsaWRQZGZCeXRlcywgY3VzdG9tT3B0aW9ucyk7XG5cbiAgICAgIGV4cGVjdChtb2NrUGRmSnNMaWIuZ2V0RG9jdW1lbnQpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFxuICAgICAgICBleHBlY3Qub2JqZWN0Q29udGFpbmluZyh7XG4gICAgICAgICAgY01hcFVybDogJy4vY3VzdG9tLWNtYXBzLycsXG4gICAgICAgICAgdmVyYm9zaXR5OiAxLFxuICAgICAgICAgIHVzZVdvcmtlckZldGNoOiBmYWxzZSwgLy8gU2hvdWxkIHN0aWxsIGhhdmUgc2FmZSBkZWZhdWx0c1xuICAgICAgICAgIGlzRXZhbFN1cHBvcnRlZDogZmFsc2VcbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgfSk7XG4gIH0pO1xufSk7XG5cbi8vIENsZWFuIHVwIGNvbnNvbGUgc3BpZXMgYWZ0ZXIgYWxsIHRlc3RzXG5hZnRlckFsbCgoKSA9PiB7XG4gIGplc3QucmVzdG9yZUFsbE1vY2tzKCk7XG59KTsiXSwidmVyc2lvbiI6M30=