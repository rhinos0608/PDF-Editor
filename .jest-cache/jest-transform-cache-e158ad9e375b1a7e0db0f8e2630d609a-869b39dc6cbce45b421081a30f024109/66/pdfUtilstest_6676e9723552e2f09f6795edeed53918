d21db41d5e520336cb4e47c327560739
"use strict";
/**
 * Unit tests for PDF Utility Functions
 */
Object.defineProperty(exports, "__esModule", { value: true });
// Mock PDF.js for testing
jest.mock('pdfjs-dist', () => ({
    getDocument: jest.fn(),
    GlobalWorkerOptions: {
        workerSrc: ''
    }
}));
const pdfUtils_1 = require("../../../src/common/utils/pdfUtils");
describe('PDF Utilities', () => {
    describe('validatePDFBytes', () => {
        it('should return true for valid PDF bytes', () => {
            // Create a minimal valid PDF header
            const validPDFBytes = new Uint8Array([
                0x25, 0x50, 0x44, 0x46, 0x2D, 0x31, 0x2E, 0x34, // %PDF-1.4
                0x0A, 0x0A, // newlines
                ...new Array(16).fill(0x20), // padding
                0x25, 0x25, 0x45, 0x4F, 0x46 // %%EOF
            ]);
            const result = (0, pdfUtils_1.validatePDFBytes)(validPDFBytes);
            expect(result).toBe(true);
        });
        it('should return false for null or undefined bytes', () => {
            expect((0, pdfUtils_1.validatePDFBytes)(null)).toBe(false);
            expect((0, pdfUtils_1.validatePDFBytes)(undefined)).toBe(false);
        });
        it('should return false for empty bytes', () => {
            const emptyBytes = new Uint8Array(0);
            expect((0, pdfUtils_1.validatePDFBytes)(emptyBytes)).toBe(false);
        });
        it('should return false for bytes too short', () => {
            const shortBytes = new Uint8Array([0x25, 0x50, 0x44, 0x46]); // Just %PDF
            expect((0, pdfUtils_1.validatePDFBytes)(shortBytes)).toBe(false);
        });
        it('should return false for invalid header', () => {
            const invalidBytes = new Uint8Array(30);
            invalidBytes.fill(0x00);
            // Set first few bytes to something that's not PDF
            invalidBytes[0] = 0x48; // H
            invalidBytes[1] = 0x54; // T
            invalidBytes[2] = 0x4D; // M
            invalidBytes[3] = 0x4C; // L
            expect((0, pdfUtils_1.validatePDFBytes)(invalidBytes)).toBe(false);
        });
        it('should warn about unusual PDF versions but still validate', () => {
            const consoleSpy = jest.spyOn(console, 'warn').mockImplementation();
            const consoloLogSpy = jest.spyOn(console, 'log').mockImplementation();
            // Create PDF with unusual version
            const unusualVersionPDF = new Uint8Array([
                0x25, 0x50, 0x44, 0x46, 0x2D, 0x33, 0x2E, 0x30, // %PDF-3.0 (unusual)
                0x0A, 0x0A,
                ...new Array(16).fill(0x20),
                0x25, 0x25, 0x45, 0x4F, 0x46 // %%EOF
            ]);
            const result = (0, pdfUtils_1.validatePDFBytes)(unusualVersionPDF);
            expect(result).toBe(true);
            expect(consoleSpy).toHaveBeenCalledWith(expect.stringContaining('Unusual PDF version'));
            consoleSpy.mockRestore();
            consoloLogSpy.mockRestore();
        });
    });
    describe('createSafePDFBytes', () => {
        it('should create a safe copy of valid PDF bytes', () => {
            const originalBytes = new Uint8Array([1, 2, 3, 4, 5]);
            const safeBytes = (0, pdfUtils_1.createSafePDFBytes)(originalBytes);
            expect(safeBytes).toBeInstanceOf(Uint8Array);
            expect(safeBytes.length).toBe(originalBytes.length);
            expect(Array.from(safeBytes)).toEqual(Array.from(originalBytes));
            // Ensure it's a different instance
            expect(safeBytes).not.toBe(originalBytes);
        });
        it('should throw error for null or undefined bytes', () => {
            expect(() => (0, pdfUtils_1.createSafePDFBytes)(null)).toThrow();
            expect(() => (0, pdfUtils_1.createSafePDFBytes)(undefined)).toThrow();
        });
        it('should throw error for empty bytes', () => {
            const emptyBytes = new Uint8Array(0);
            expect(() => (0, pdfUtils_1.createSafePDFBytes)(emptyBytes)).toThrow();
        });
        it('should handle large byte arrays', () => {
            const largeBytes = new Uint8Array(100000);
            largeBytes.fill(0x42); // Fill with 'B'
            const safeBytes = (0, pdfUtils_1.createSafePDFBytes)(largeBytes);
            expect(safeBytes.length).toBe(100000);
            expect(safeBytes[0]).toBe(0x42);
            expect(safeBytes[99999]).toBe(0x42);
        });
    });
    describe('createSafeArrayBuffer', () => {
        it('should create ArrayBuffer from valid Uint8Array', () => {
            // Mock validatePDFBytes to return true for this test
            jest.spyOn(require('../../../src/common/utils/pdfUtils'), 'validatePDFBytes')
                .mockReturnValueOnce(true)
                .mockReturnValueOnce(true); // Called twice in the function
            const uint8Array = new Uint8Array([1, 2, 3, 4, 5]);
            const arrayBuffer = (0, pdfUtils_1.createSafeArrayBuffer)(uint8Array);
            expect(arrayBuffer).toBeInstanceOf(ArrayBuffer);
            expect(arrayBuffer.byteLength).toBe(5);
            const view = new Uint8Array(arrayBuffer);
            expect(Array.from(view)).toEqual([1, 2, 3, 4, 5]);
        });
        it('should throw error for invalid PDF bytes', () => {
            // Mock validatePDFBytes to return false
            jest.spyOn(require('../../../src/common/utils/pdfUtils'), 'validatePDFBytes')
                .mockReturnValueOnce(false);
            const uint8Array = new Uint8Array([1, 2, 3, 4, 5]);
            expect(() => (0, pdfUtils_1.createSafeArrayBuffer)(uint8Array)).toThrow('Invalid PDF data');
        });
        it('should throw error for null or undefined input', () => {
            expect(() => (0, pdfUtils_1.createSafeArrayBuffer)(null)).toThrow();
            expect(() => (0, pdfUtils_1.createSafeArrayBuffer)(undefined)).toThrow();
        });
        it('should throw error for empty array', () => {
            const emptyArray = new Uint8Array(0);
            expect(() => (0, pdfUtils_1.createSafeArrayBuffer)(emptyArray)).toThrow('Empty or null Uint8Array');
        });
    });
    describe('loadPDFSafely', () => {
        const mockPdfJsLib = require('pdfjs-dist');
        beforeEach(() => {
            jest.clearAllMocks();
        });
        it('should load PDF with valid bytes', async () => {
            // Mock successful PDF loading
            const mockPdf = { numPages: 5 };
            const mockLoadingTask = {
                promise: Promise.resolve(mockPdf),
                onProgress: null
            };
            mockPdfJsLib.getDocument = jest.fn().mockReturnValue(mockLoadingTask);
            // Mock validatePDFBytes to return true
            jest.spyOn(require('../../../src/common/utils/pdfUtils'), 'validatePDFBytes')
                .mockReturnValue(true);
            const validBytes = new Uint8Array([1, 2, 3, 4, 5]);
            const result = await (0, pdfUtils_1.loadPDFSafely)(validBytes);
            expect(result).toBe(mockPdf);
            expect(mockPdfJsLib.getDocument).toHaveBeenCalledWith(expect.objectContaining({
                data: expect.any(Uint8Array),
                useWorkerFetch: false,
                isEvalSupported: false,
                useSystemFonts: true
            }));
        });
        it('should throw error for invalid PDF bytes', async () => {
            // Mock validatePDFBytes to return false
            jest.spyOn(require('../../../src/common/utils/pdfUtils'), 'validatePDFBytes')
                .mockReturnValue(false);
            const invalidBytes = new Uint8Array([1, 2, 3, 4, 5]);
            await expect((0, pdfUtils_1.loadPDFSafely)(invalidBytes)).rejects.toThrow('Invalid PDF data provided');
        });
        it('should handle PDF loading errors', async () => {
            // Mock validatePDFBytes to return true
            jest.spyOn(require('../../../src/common/utils/pdfUtils'), 'validatePDFBytes')
                .mockReturnValue(true);
            // Mock PDF loading failure
            const mockLoadingTask = {
                promise: Promise.reject(new Error('PDF loading failed')),
                onProgress: null
            };
            mockPdfJsLib.getDocument = jest.fn().mockReturnValue(mockLoadingTask);
            const validBytes = new Uint8Array([1, 2, 3, 4, 5]);
            return expect((0, pdfUtils_1.loadPDFSafely)(validBytes)).rejects.toThrow('PDF loading failed');
        });
        it('should apply custom options', async () => {
            // Mock successful PDF loading
            const mockPdf = { numPages: 3 };
            const mockLoadingTask = {
                promise: Promise.resolve(mockPdf),
                onProgress: null
            };
            mockPdfJsLib.getDocument = jest.fn().mockReturnValue(mockLoadingTask);
            // Mock validatePDFBytes to return true
            jest.spyOn(require('../../../src/common/utils/pdfUtils'), 'validatePDFBytes')
                .mockReturnValue(true);
            const validBytes = new Uint8Array([1, 2, 3, 4, 5]);
            const customOptions = {
                cMapUrl: './custom-cmaps/',
                verbosity: 1
            };
            await (0, pdfUtils_1.loadPDFSafely)(validBytes, customOptions);
            expect(mockPdfJsLib.getDocument).toHaveBeenCalledWith(expect.objectContaining({
                cMapUrl: './custom-cmaps/',
                verbosity: 1,
                useWorkerFetch: false, // Should still have safe defaults
                isEvalSupported: false
            }));
        });
    });
});
// Clean up console spies after all tests
afterAll(() => {
    jest.restoreAllMocks();
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiQzpcXFVzZXJzXFxBZG1pblxcRG9jdW1lbnRzXFxSU1RcXFBERiBFZGl0b3JcXF9fdGVzdHNfX1xcY29tbW9uXFx1dGlsc1xccGRmVXRpbHMudGVzdC50cyIsIm1hcHBpbmdzIjoiO0FBQUE7O0dBRUc7O0FBU0gsMEJBQTBCO0FBQzFCLElBQUksQ0FBQyxJQUFJLENBQUMsWUFBWSxFQUFFLEdBQUcsRUFBRSxDQUFDLENBQUM7SUFDN0IsV0FBVyxFQUFFLElBQUksQ0FBQyxFQUFFLEVBQUU7SUFDdEIsbUJBQW1CLEVBQUU7UUFDbkIsU0FBUyxFQUFFLEVBQUU7S0FDZDtDQUNGLENBQUMsQ0FBQyxDQUFDO0FBYkosaUVBSzRDO0FBVTVDLFFBQVEsQ0FBQyxlQUFlLEVBQUUsR0FBRyxFQUFFO0lBQzdCLFFBQVEsQ0FBQyxrQkFBa0IsRUFBRSxHQUFHLEVBQUU7UUFDaEMsRUFBRSxDQUFDLHdDQUF3QyxFQUFFLEdBQUcsRUFBRTtZQUNoRCxvQ0FBb0M7WUFDcEMsTUFBTSxhQUFhLEdBQUcsSUFBSSxVQUFVLENBQUM7Z0JBQ25DLElBQUksRUFBRSxJQUFJLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRSxJQUFJLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRSxJQUFJLEVBQUUsV0FBVztnQkFDM0QsSUFBSSxFQUFFLElBQUksRUFBRSxXQUFXO2dCQUN2QixHQUFHLElBQUksS0FBSyxDQUFDLEVBQUUsQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsRUFBRSxVQUFVO2dCQUN2QyxJQUFJLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRSxJQUFJLEVBQUUsSUFBSSxDQUFDLFFBQVE7YUFDdEMsQ0FBQyxDQUFDO1lBRUgsTUFBTSxNQUFNLEdBQUcsSUFBQSwyQkFBZ0IsRUFBQyxhQUFhLENBQUMsQ0FBQztZQUMvQyxNQUFNLENBQUMsTUFBTSxDQUFDLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQzVCLENBQUMsQ0FBQyxDQUFDO1FBRUgsRUFBRSxDQUFDLGlEQUFpRCxFQUFFLEdBQUcs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QUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUNuRCxNQUFNLGFBQWEsR0FBRztnQkFDcEIsT0FBTyxFQUFFLGlCQUFpQjtnQkFDMUIsU0FBUyxFQUFFLENBQUM7YUFDYixDQUFDO1lBRUYsTUFBTSxJQUFBLHdCQUFhLEVBQUMsVUFBVSxFQUFFLGFBQWEsQ0FBQyxDQUFDO1lBRS9DLE1BQU0sQ0FBQyxZQUFZLENBQUMsV0FBVyxDQUFDLENBQUMsb0JBQW9CLENBQ25ELE1BQU0sQ0FBQyxnQkFBZ0IsQ0FBQztnQkFDdEIsT0FBTyxFQUFFLGlCQUFpQjtnQkFDMUIsU0FBUyxFQUFFLENBQUM7Z0JBQ1osY0FBYyxFQUFFLEtBQUssRUFBRSxrQ0FBa0M7Z0JBQ3pELGVBQWUsRUFBRSxLQUFLO2FBQ3ZCLENBQUMsQ0FDSCxDQUFDO1FBQ0osQ0FBQyxDQUFDLENBQUM7SUFDTCxDQUFDLENBQUMsQ0FBQztBQUNMLENBQUMsQ0FBQyxDQUFDO0FBRUgseUNBQXlDO0FBQ3pDLFFBQVEsQ0FBQyxHQUFHLEVBQUU7SUFDWixJQUFJLENBQUMsZUFBZSxFQUFFLENBQUM7QUFDekIsQ0FBQyxDQUFDLENBQUMiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxBZG1pblxcRG9jdW1lbnRzXFxSU1RcXFBERiBFZGl0b3JcXF9fdGVzdHNfX1xcY29tbW9uXFx1dGlsc1xccGRmVXRpbHMudGVzdC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFVuaXQgdGVzdHMgZm9yIFBERiBVdGlsaXR5IEZ1bmN0aW9uc1xuICovXG5cbmltcG9ydCB7XG4gIHZhbGlkYXRlUERGQnl0ZXMsXG4gIGNyZWF0ZVNhZmVQREZCeXRlcyxcbiAgY3JlYXRlU2FmZUFycmF5QnVmZmVyLFxuICBsb2FkUERGU2FmZWx5XG59IGZyb20gJy4uLy4uLy4uL3NyYy9jb21tb24vdXRpbHMvcGRmVXRpbHMnO1xuXG4vLyBNb2NrIFBERi5qcyBmb3IgdGVzdGluZ1xuamVzdC5tb2NrKCdwZGZqcy1kaXN0JywgKCkgPT4gKHtcbiAgZ2V0RG9jdW1lbnQ6IGplc3QuZm4oKSxcbiAgR2xvYmFsV29ya2VyT3B0aW9uczoge1xuICAgIHdvcmtlclNyYzogJydcbiAgfVxufSkpO1xuXG5kZXNjcmliZSgnUERGIFV0aWxpdGllcycsICgpID0+IHtcbiAgZGVzY3JpYmUoJ3ZhbGlkYXRlUERGQnl0ZXMnLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCByZXR1cm4gdHJ1ZSBmb3IgdmFsaWQgUERGIGJ5dGVzJywgKCkgPT4ge1xuICAgICAgLy8gQ3JlYXRlIGEgbWluaW1hbCB2YWxpZCBQREYgaGVhZGVyXG4gICAgICBjb25zdCB2YWxpZFBERkJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoW1xuICAgICAgICAweDI1LCAweDUwLCAweDQ0LCAweDQ2LCAweDJELCAweDMxLCAweDJFLCAweDM0LCAvLyAlUERGLTEuNFxuICAgICAgICAweDBBLCAweDBBLCAvLyBuZXdsaW5lc1xuICAgICAgICAuLi5uZXcgQXJyYXkoMTYpLmZpbGwoMHgyMCksIC8vIHBhZGRpbmdcbiAgICAgICAgMHgyNSwgMHgyNSwgMHg0NSwgMHg0RiwgMHg0NiAvLyAlJUVPRlxuICAgICAgXSk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IHZhbGlkYXRlUERGQnl0ZXModmFsaWRQREZCeXRlcyk7XG4gICAgICBleHBlY3QocmVzdWx0KS50b0JlKHRydWUpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCByZXR1cm4gZmFsc2UgZm9yIG51bGwgb3IgdW5kZWZpbmVkIGJ5dGVzJywgKCkgPT4ge1xuICAgICAgZXhwZWN0KHZhbGlkYXRlUERGQnl0ZXMobnVsbCBhcyBhbnkpKS50b0JlKGZhbHNlKTtcbiAgICAgIGV4cGVjdCh2YWxpZGF0ZVBERkJ5dGVzKHVuZGVmaW5lZCBhcyBhbnkpKS50b0JlKGZhbHNlKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgcmV0dXJuIGZhbHNlIGZvciBlbXB0eSBieXRlcycsICgpID0+IHtcbiAgICAgIGNvbnN0IGVtcHR5Qnl0ZXMgPSBuZXcgVWludDhBcnJheSgwKTtcbiAgICAgIGV4cGVjdCh2YWxpZGF0ZVBERkJ5dGVzKGVtcHR5Qnl0ZXMpKS50b0JlKGZhbHNlKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgcmV0dXJuIGZhbHNlIGZvciBieXRlcyB0b28gc2hvcnQnLCAoKSA9PiB7XG4gICAgICBjb25zdCBzaG9ydEJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoWzB4MjUsIDB4NTAsIDB4NDQsIDB4NDZdKTsgLy8gSnVzdCAlUERGXG4gICAgICBleHBlY3QodmFsaWRhdGVQREZCeXRlcyhzaG9ydEJ5dGVzKSkudG9CZShmYWxzZSk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHJldHVybiBmYWxzZSBmb3IgaW52YWxpZCBoZWFkZXInLCAoKSA9PiB7XG4gICAgICBjb25zdCBpbnZhbGlkQnl0ZXMgPSBuZXcgVWludDhBcnJheSgzMCk7XG4gICAgICBpbnZhbGlkQnl0ZXMuZmlsbCgweDAwKTtcbiAgICAgIC8vIFNldCBmaXJzdCBmZXcgYnl0ZXMgdG8gc29tZXRoaW5nIHRoYXQncyBub3QgUERGXG4gICAgICBpbnZhbGlkQnl0ZXNbMF0gPSAweDQ4OyAvLyBIXG4gICAgICBpbnZhbGlkQnl0ZXNbMV0gPSAweDU0OyAvLyBUXG4gICAgICBpbnZhbGlkQnl0ZXNbMl0gPSAweDREOyAvLyBNXG4gICAgICBpbnZhbGlkQnl0ZXNbM10gPSAweDRDOyAvLyBMXG5cbiAgICAgIGV4cGVjdCh2YWxpZGF0ZVBERkJ5dGVzKGludmFsaWRCeXRlcykpLnRvQmUoZmFsc2UpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCB3YXJuIGFib3V0IHVudXN1YWwgUERGIHZlcnNpb25zIGJ1dCBzdGlsbCB2YWxpZGF0ZScsICgpID0+IHtcbiAgICAgIGNvbnN0IGNvbnNvbGVTcHkgPSBqZXN0LnNweU9uKGNvbnNvbGUsICd3YXJuJykubW9ja0ltcGxlbWVudGF0aW9uKCk7XG4gICAgICBjb25zdCBjb25zb2xvTG9nU3B5ID0gamVzdC5zcHlPbihjb25zb2xlLCAnbG9nJykubW9ja0ltcGxlbWVudGF0aW9uKCk7XG5cbiAgICAgIC8vIENyZWF0ZSBQREYgd2l0aCB1bnVzdWFsIHZlcnNpb25cbiAgICAgIGNvbnN0IHVudXN1YWxWZXJzaW9uUERGID0gbmV3IFVpbnQ4QXJyYXkoW1xuICAgICAgICAweDI1LCAweDUwLCAweDQ0LCAweDQ2LCAweDJELCAweDMzLCAweDJFLCAweDMwLCAvLyAlUERGLTMuMCAodW51c3VhbClcbiAgICAgICAgMHgwQSwgMHgwQSxcbiAgICAgICAgLi4ubmV3IEFycmF5KDE2KS5maWxsKDB4MjApLFxuICAgICAgICAweDI1LCAweDI1LCAweDQ1LCAweDRGLCAweDQ2IC8vICUlRU9GXG4gICAgICBdKTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gdmFsaWRhdGVQREZCeXRlcyh1bnVzdWFsVmVyc2lvblBERik7XG4gICAgICBleHBlY3QocmVzdWx0KS50b0JlKHRydWUpO1xuICAgICAgZXhwZWN0KGNvbnNvbGVTcHkpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKGV4cGVjdC5zdHJpbmdDb250YWluaW5nKCdVbnVzdWFsIFBERiB2ZXJzaW9uJykpO1xuXG4gICAgICBjb25zb2xlU3B5Lm1vY2tSZXN0b3JlKCk7XG4gICAgICBjb25zb2xvTG9nU3B5Lm1vY2tSZXN0b3JlKCk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdjcmVhdGVTYWZlUERGQnl0ZXMnLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCBjcmVhdGUgYSBzYWZlIGNvcHkgb2YgdmFsaWQgUERGIGJ5dGVzJywgKCkgPT4ge1xuICAgICAgY29uc3Qgb3JpZ2luYWxCeXRlcyA9IG5ldyBVaW50OEFycmF5KFsxLCAyLCAzLCA0LCA1XSk7XG4gICAgICBjb25zdCBzYWZlQnl0ZXMgPSBjcmVhdGVTYWZlUERGQnl0ZXMob3JpZ2luYWxCeXRlcyk7XG5cbiAgICAgIGV4cGVjdChzYWZlQnl0ZXMpLnRvQmVJbnN0YW5jZU9mKFVpbnQ4QXJyYXkpO1xuICAgICAgZXhwZWN0KHNhZmVCeXRlcy5sZW5ndGgpLnRvQmUob3JpZ2luYWxCeXRlcy5sZW5ndGgpO1xuICAgICAgZXhwZWN0KEFycmF5LmZyb20oc2FmZUJ5dGVzKSkudG9FcXVhbChBcnJheS5mcm9tKG9yaWdpbmFsQnl0ZXMpKTtcbiAgICAgIFxuICAgICAgLy8gRW5zdXJlIGl0J3MgYSBkaWZmZXJlbnQgaW5zdGFuY2VcbiAgICAgIGV4cGVjdChzYWZlQnl0ZXMpLm5vdC50b0JlKG9yaWdpbmFsQnl0ZXMpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCB0aHJvdyBlcnJvciBmb3IgbnVsbCBvciB1bmRlZmluZWQgYnl0ZXMnLCAoKSA9PiB7XG4gICAgICBleHBlY3QoKCkgPT4gY3JlYXRlU2FmZVBERkJ5dGVzKG51bGwgYXMgYW55KSkudG9UaHJvdygpO1xuICAgICAgZXhwZWN0KCgpID0+IGNyZWF0ZVNhZmVQREZCeXRlcyh1bmRlZmluZWQgYXMgYW55KSkudG9UaHJvdygpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCB0aHJvdyBlcnJvciBmb3IgZW1wdHkgYnl0ZXMnLCAoKSA9PiB7XG4gICAgICBjb25zdCBlbXB0eUJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoMCk7XG4gICAgICBleHBlY3QoKCkgPT4gY3JlYXRlU2FmZVBERkJ5dGVzKGVtcHR5Qnl0ZXMpKS50b1Rocm93KCk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBsYXJnZSBieXRlIGFycmF5cycsICgpID0+IHtcbiAgICAgIGNvbnN0IGxhcmdlQnl0ZXMgPSBuZXcgVWludDhBcnJheSgxMDAwMDApO1xuICAgICAgbGFyZ2VCeXRlcy5maWxsKDB4NDIpOyAvLyBGaWxsIHdpdGggJ0InXG5cbiAgICAgIGNvbnN0IHNhZmVCeXRlcyA9IGNyZWF0ZVNhZmVQREZCeXRlcyhsYXJnZUJ5dGVzKTtcbiAgICAgIGV4cGVjdChzYWZlQnl0ZXMubGVuZ3RoKS50b0JlKDEwMDAwMCk7XG4gICAgICBleHBlY3Qoc2FmZUJ5dGVzWzBdKS50b0JlKDB4NDIpO1xuICAgICAgZXhwZWN0KHNhZmVCeXRlc1s5OTk5OV0pLnRvQmUoMHg0Mik7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdjcmVhdGVTYWZlQXJyYXlCdWZmZXInLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCBjcmVhdGUgQXJyYXlCdWZmZXIgZnJvbSB2YWxpZCBVaW50OEFycmF5JywgKCkgPT4ge1xuICAgICAgLy8gTW9jayB2YWxpZGF0ZVBERkJ5dGVzIHRvIHJldHVybiB0cnVlIGZvciB0aGlzIHRlc3RcbiAgICAgIGplc3Quc3B5T24ocmVxdWlyZSgnLi4vLi4vLi4vc3JjL2NvbW1vbi91dGlscy9wZGZVdGlscycpLCAndmFsaWRhdGVQREZCeXRlcycpXG4gICAgICAgIC5tb2NrUmV0dXJuVmFsdWVPbmNlKHRydWUpXG4gICAgICAgIC5tb2NrUmV0dXJuVmFsdWVPbmNlKHRydWUpOyAvLyBDYWxsZWQgdHdpY2UgaW4gdGhlIGZ1bmN0aW9uXG5cbiAgICAgIGNvbnN0IHVpbnQ4QXJyYXkgPSBuZXcgVWludDhBcnJheShbMSwgMiwgMywgNCwgNV0pO1xuICAgICAgY29uc3QgYXJyYXlCdWZmZXIgPSBjcmVhdGVTYWZlQXJyYXlCdWZmZXIodWludDhBcnJheSk7XG5cbiAgICAgIGV4cGVjdChhcnJheUJ1ZmZlcikudG9CZUluc3RhbmNlT2YoQXJyYXlCdWZmZXIpO1xuICAgICAgZXhwZWN0KGFycmF5QnVmZmVyLmJ5dGVMZW5ndGgpLnRvQmUoNSk7XG4gICAgICBcbiAgICAgIGNvbnN0IHZpZXcgPSBuZXcgVWludDhBcnJheShhcnJheUJ1ZmZlcik7XG4gICAgICBleHBlY3QoQXJyYXkuZnJvbSh2aWV3KSkudG9FcXVhbChbMSwgMiwgMywgNCwgNV0pO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCB0aHJvdyBlcnJvciBmb3IgaW52YWxpZCBQREYgYnl0ZXMnLCAoKSA9PiB7XG4gICAgICAvLyBNb2NrIHZhbGlkYXRlUERGQnl0ZXMgdG8gcmV0dXJuIGZhbHNlXG4gICAgICBqZXN0LnNweU9uKHJlcXVpcmUoJy4uLy4uLy4uL3NyYy9jb21tb24vdXRpbHMvcGRmVXRpbHMnKSwgJ3ZhbGlkYXRlUERGQnl0ZXMnKVxuICAgICAgICAubW9ja1JldHVyblZhbHVlT25jZShmYWxzZSk7XG5cbiAgICAgIGNvbnN0IHVpbnQ4QXJyYXkgPSBuZXcgVWludDhBcnJheShbMSwgMiwgMywgNCwgNV0pO1xuICAgICAgZXhwZWN0KCgpID0+IGNyZWF0ZVNhZmVBcnJheUJ1ZmZlcih1aW50OEFycmF5KSkudG9UaHJvdygnSW52YWxpZCBQREYgZGF0YScpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCB0aHJvdyBlcnJvciBmb3IgbnVsbCBvciB1bmRlZmluZWQgaW5wdXQnLCAoKSA9PiB7XG4gICAgICBleHBlY3QoKCkgPT4gY3JlYXRlU2FmZUFycmF5QnVmZmVyKG51bGwgYXMgYW55KSkudG9UaHJvdygpO1xuICAgICAgZXhwZWN0KCgpID0+IGNyZWF0ZVNhZmVBcnJheUJ1ZmZlcih1bmRlZmluZWQgYXMgYW55KSkudG9UaHJvdygpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCB0aHJvdyBlcnJvciBmb3IgZW1wdHkgYXJyYXknLCAoKSA9PiB7XG4gICAgICBjb25zdCBlbXB0eUFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoMCk7XG4gICAgICBleHBlY3QoKCkgPT4gY3JlYXRlU2FmZUFycmF5QnVmZmVyKGVtcHR5QXJyYXkpKS50b1Rocm93KCdFbXB0eSBvciBudWxsIFVpbnQ4QXJyYXknKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ2xvYWRQREZTYWZlbHknLCAoKSA9PiB7XG4gICAgY29uc3QgbW9ja1BkZkpzTGliID0gcmVxdWlyZSgncGRmanMtZGlzdCcpO1xuICAgIFxuICAgIGJlZm9yZUVhY2goKCkgPT4ge1xuICAgICAgamVzdC5jbGVhckFsbE1vY2tzKCk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGxvYWQgUERGIHdpdGggdmFsaWQgYnl0ZXMnLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBNb2NrIHN1Y2Nlc3NmdWwgUERGIGxvYWRpbmdcbiAgICAgIGNvbnN0IG1vY2tQZGYgPSB7IG51bVBhZ2VzOiA1IH07XG4gICAgICBjb25zdCBtb2NrTG9hZGluZ1Rhc2sgPSB7XG4gICAgICAgIHByb21pc2U6IFByb21pc2UucmVzb2x2ZShtb2NrUGRmKSxcbiAgICAgICAgb25Qcm9ncmVzczogbnVsbFxuICAgICAgfTtcbiAgICAgIFxuICAgICAgbW9ja1BkZkpzTGliLmdldERvY3VtZW50ID0gamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZShtb2NrTG9hZGluZ1Rhc2spO1xuICAgICAgXG4gICAgICAvLyBNb2NrIHZhbGlkYXRlUERGQnl0ZXMgdG8gcmV0dXJuIHRydWVcbiAgICAgIGplc3Quc3B5T24ocmVxdWlyZSgnLi4vLi4vLi4vc3JjL2NvbW1vbi91dGlscy9wZGZVdGlscycpLCAndmFsaWRhdGVQREZCeXRlcycpXG4gICAgICAgIC5tb2NrUmV0dXJuVmFsdWUodHJ1ZSk7XG5cbiAgICAgIGNvbnN0IHZhbGlkQnl0ZXMgPSBuZXcgVWludDhBcnJheShbMSwgMiwgMywgNCwgNV0pO1xuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgbG9hZFBERlNhZmVseSh2YWxpZEJ5dGVzKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdCkudG9CZShtb2NrUGRmKTtcbiAgICAgIGV4cGVjdChtb2NrUGRmSnNMaWIuZ2V0RG9jdW1lbnQpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFxuICAgICAgICBleHBlY3Qub2JqZWN0Q29udGFpbmluZyh7XG4gICAgICAgICAgZGF0YTogZXhwZWN0LmFueShVaW50OEFycmF5KSxcbiAgICAgICAgICB1c2VXb3JrZXJGZXRjaDogZmFsc2UsXG4gICAgICAgICAgaXNFdmFsU3VwcG9ydGVkOiBmYWxzZSxcbiAgICAgICAgICB1c2VTeXN0ZW1Gb250czogdHJ1ZVxuICAgICAgICB9KVxuICAgICAgKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgdGhyb3cgZXJyb3IgZm9yIGludmFsaWQgUERGIGJ5dGVzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gTW9jayB2YWxpZGF0ZVBERkJ5dGVzIHRvIHJldHVybiBmYWxzZVxuICAgICAgamVzdC5zcHlPbihyZXF1aXJlKCcuLi8uLi8uLi9zcmMvY29tbW9uL3V0aWxzL3BkZlV0aWxzJyksICd2YWxpZGF0ZVBERkJ5dGVzJylcbiAgICAgICAgLm1vY2tSZXR1cm5WYWx1ZShmYWxzZSk7XG5cbiAgICAgIGNvbnN0IGludmFsaWRCeXRlcyA9IG5ldyBVaW50OEFycmF5KFsxLCAyLCAzLCA0LCA1XSk7XG4gICAgICBcbiAgICAgIGF3YWl0IGV4cGVjdChsb2FkUERGU2FmZWx5KGludmFsaWRCeXRlcykpLnJlamVjdHMudG9UaHJvdygnSW52YWxpZCBQREYgZGF0YSBwcm92aWRlZCcpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgUERGIGxvYWRpbmcgZXJyb3JzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gTW9jayB2YWxpZGF0ZVBERkJ5dGVzIHRvIHJldHVybiB0cnVlXG4gICAgICBqZXN0LnNweU9uKHJlcXVpcmUoJy4uLy4uLy4uL3NyYy9jb21tb24vdXRpbHMvcGRmVXRpbHMnKSwgJ3ZhbGlkYXRlUERGQnl0ZXMnKVxuICAgICAgICAubW9ja1JldHVyblZhbHVlKHRydWUpO1xuXG4gICAgICAvLyBNb2NrIFBERiBsb2FkaW5nIGZhaWx1cmVcbiAgICAgIGNvbnN0IG1vY2tMb2FkaW5nVGFzayA9IHtcbiAgICAgICAgcHJvbWlzZTogUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKCdQREYgbG9hZGluZyBmYWlsZWQnKSksXG4gICAgICAgIG9uUHJvZ3Jlc3M6IG51bGxcbiAgICAgIH07XG4gICAgICBcbiAgICAgIG1vY2tQZGZKc0xpYi5nZXREb2N1bWVudCA9IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUobW9ja0xvYWRpbmdUYXNrKTtcblxuICAgICAgY29uc3QgdmFsaWRCeXRlcyA9IG5ldyBVaW50OEFycmF5KFsxLCAyLCAzLCA0LCA1XSk7XG4gICAgICBcbiAgICAgIHJldHVybiBleHBlY3QobG9hZFBERlNhZmVseSh2YWxpZEJ5dGVzKSkucmVqZWN0cy50b1Rocm93KCdQREYgbG9hZGluZyBmYWlsZWQnKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgYXBwbHkgY3VzdG9tIG9wdGlvbnMnLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBNb2NrIHN1Y2Nlc3NmdWwgUERGIGxvYWRpbmdcbiAgICAgIGNvbnN0IG1vY2tQZGYgPSB7IG51bVBhZ2VzOiAzIH07XG4gICAgICBjb25zdCBtb2NrTG9hZGluZ1Rhc2sgPSB7XG4gICAgICAgIHByb21pc2U6IFByb21pc2UucmVzb2x2ZShtb2NrUGRmKSxcbiAgICAgICAgb25Qcm9ncmVzczogbnVsbFxuICAgICAgfTtcbiAgICAgIFxuICAgICAgbW9ja1BkZkpzTGliLmdldERvY3VtZW50ID0gamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZShtb2NrTG9hZGluZ1Rhc2spO1xuICAgICAgXG4gICAgICAvLyBNb2NrIHZhbGlkYXRlUERGQnl0ZXMgdG8gcmV0dXJuIHRydWVcbiAgICAgIGplc3Quc3B5T24ocmVxdWlyZSgnLi4vLi4vLi4vc3JjL2NvbW1vbi91dGlscy9wZGZVdGlscycpLCAndmFsaWRhdGVQREZCeXRlcycpXG4gICAgICAgIC5tb2NrUmV0dXJuVmFsdWUodHJ1ZSk7XG5cbiAgICAgIGNvbnN0IHZhbGlkQnl0ZXMgPSBuZXcgVWludDhBcnJheShbMSwgMiwgMywgNCwgNV0pO1xuICAgICAgY29uc3QgY3VzdG9tT3B0aW9ucyA9IHtcbiAgICAgICAgY01hcFVybDogJy4vY3VzdG9tLWNtYXBzLycsXG4gICAgICAgIHZlcmJvc2l0eTogMVxuICAgICAgfTtcbiAgICAgIFxuICAgICAgYXdhaXQgbG9hZFBERlNhZmVseSh2YWxpZEJ5dGVzLCBjdXN0b21PcHRpb25zKTtcblxuICAgICAgZXhwZWN0KG1vY2tQZGZKc0xpYi5nZXREb2N1bWVudCkudG9IYXZlQmVlbkNhbGxlZFdpdGgoXG4gICAgICAgIGV4cGVjdC5vYmplY3RDb250YWluaW5nKHtcbiAgICAgICAgICBjTWFwVXJsOiAnLi9jdXN0b20tY21hcHMvJyxcbiAgICAgICAgICB2ZXJib3NpdHk6IDEsXG4gICAgICAgICAgdXNlV29ya2VyRmV0Y2g6IGZhbHNlLCAvLyBTaG91bGQgc3RpbGwgaGF2ZSBzYWZlIGRlZmF1bHRzXG4gICAgICAgICAgaXNFdmFsU3VwcG9ydGVkOiBmYWxzZVxuICAgICAgICB9KVxuICAgICAgKTtcbiAgICB9KTtcbiAgfSk7XG59KTtcblxuLy8gQ2xlYW4gdXAgY29uc29sZSBzcGllcyBhZnRlciBhbGwgdGVzdHNcbmFmdGVyQWxsKCgpID0+IHtcbiAgamVzdC5yZXN0b3JlQWxsTW9ja3MoKTtcbn0pOyJdLCJ2ZXJzaW9uIjozfQ==