/**\n * Enhanced Preload script for Professional PDF Editor\n * Provides secure bridge between main and renderer processes\n * Comprehensive API exposure with premium features and security validation\n */\n\nconst { contextBridge, ipcRenderer } = require('electron');\n\n// Validate that we're in the correct context\nif (!process.contextIsolated) {\n  throw new Error('Context isolation must be enabled for security');\n}\n\n// Security: Validate IPC responses to prevent injection attacks\nfunction validateResponse(response) {\n  if (typeof response !== 'object' || response === null) {\n    return false;\n  }\n  \n  // Check for required properties\n  if (!response.hasOwnProperty('success')) {\n    return false;\n  }\n  \n  return true;\n}\n\n// Enhanced error handling for IPC calls\nfunction handleIPCError(error, operation) {\n  console.error(`IPC ${operation} failed:`, error);\n  return {\n    success: false,\n    error: error.message || 'Unknown error occurred',\n    operation\n  };\n}\n\n// Progress tracking utilities\nconst progressCallbacks = new Map();\n\nfunction setupProgressListener(eventName, callback) {\n  if (typeof callback !== 'function') return;\n  \n  const wrappedCallback = (event, data) => {\n    try {\n      callback(data);\n    } catch (error) {\n      console.error(`Progress callback error for ${eventName}:`, error);\n    }\n  };\n  \n  ipcRenderer.on(eventName, wrappedCallback);\n  progressCallbacks.set(eventName, wrappedCallback);\n  \n  return () => {\n    ipcRenderer.removeListener(eventName, wrappedCallback);\n    progressCallbacks.delete(eventName);\n  };\n}\n\n// Enhanced API object with comprehensive premium functionality\nconst electronAPI = {\n  // ===== CORE FILE OPERATIONS =====\n  openFile: () => {\n    try {\n      return ipcRenderer.invoke('open-file');\n    } catch (error) {\n      return handleIPCError(error, 'openFile');\n    }\n  },\n  \n  saveFile: (filePath, data) => {\n    try {\n      if (!filePath || !data) {\n        throw new Error('Invalid file save parameters');\n      }\n      return ipcRenderer.invoke('save-file', filePath, data);\n    } catch (error) {\n      return handleIPCError(error, 'saveFile');\n    }\n  },\n  \n  saveFileDialog: (defaultName) => {\n    try {\n      return ipcRenderer.invoke('save-file-dialog', defaultName);\n    } catch (error) {\n      return handleIPCError(error, 'saveFileDialog');\n    }\n  },\n\n  // ===== OCR OPERATIONS =====\n  performOCR: (pdfData, pageNumber, language = 'eng') => {\n    try {\n      if (!pdfData || !pageNumber) {\n        throw new Error('Invalid OCR parameters');\n      }\n      return ipcRenderer.invoke('perform-ocr', pdfData, pageNumber, language);\n    } catch (error) {\n      return handleIPCError(error, 'performOCR');\n    }\n  },\n  \n  batchOCR: (pdfData, pageNumbers, language = 'eng') => {\n    try {\n      if (!pdfData || !Array.isArray(pageNumbers)) {\n        throw new Error('Invalid batch OCR parameters');\n      }\n      return ipcRenderer.invoke('batch-ocr', pdfData, pageNumbers, language);\n    } catch (error) {\n      return handleIPCError(error, 'batchOCR');\n    }\n  },\n  \n  onOCRProgress: (callback) => {\n    return setupProgressListener('ocr-progress', callback);\n  },\n\n  // ===== DIGITAL SIGNATURE OPERATIONS =====\n  createDigitalSignature: (pdfData, signatureData) => {\n    try {\n      if (!pdfData || !signatureData) {\n        throw new Error('Invalid signature parameters');\n      }\n      return ipcRenderer.invoke('create-digital-signature', pdfData, signatureData);\n    } catch (error) {\n      return handleIPCError(error, 'createDigitalSignature');\n    }\n  },\n  \n  validateSignature: (pdfData, signatureId) => {\n    try {\n      if (!pdfData || !signatureId) {\n        throw new Error('Invalid signature validation parameters');\n      }\n      return ipcRenderer.invoke('validate-signature', pdfData, signatureId);\n    } catch (error) {\n      return handleIPCError(error, 'validateSignature');\n    }\n  },\n\n  // ===== BATCH PROCESSING OPERATIONS =====\n  batchProcess: (operations) => {\n    try {\n      if (!Array.isArray(operations)) {\n        throw new Error('Operations must be an array');\n      }\n      return ipcRenderer.invoke('batch-process', operations);\n    } catch (error) {\n      return handleIPCError(error, 'batchProcess');\n    }\n  },\n  \n  onBatchProgress: (callback) => {\n    return setupProgressListener('batch-progress', callback);\n  },\n\n  // ===== DOCUMENT ANALYSIS =====\n  analyzeDocument: (pdfData, analysisType) => {\n    try {\n      if (!pdfData || !analysisType) {\n        throw new Error('Invalid document analysis parameters');\n      }\n      return ipcRenderer.invoke('analyze-document', pdfData, analysisType);\n    } catch (error) {\n      return handleIPCError(error, 'analyzeDocument');\n    }\n  },\n\n  // ===== ADVANCED FILE OPERATIONS =====\n  mergePDFs: (pdfFiles, options = {}) => {\n    try {\n      if (!Array.isArray(pdfFiles) || pdfFiles.length < 2) {\n        throw new Error('At least 2 PDF files required for merging');\n      }\n      return ipcRenderer.invoke('merge-pdfs', pdfFiles, options);\n    } catch (error) {\n      return handleIPCError(error, 'mergePDFs');\n    }\n  },\n  \n  splitPDF: (pdfData, splitOptions) => {\n    try {\n      if (!pdfData || !splitOptions) {\n        throw new Error('Invalid split parameters');\n      }\n      return ipcRenderer.invoke('split-pdf', pdfData, splitOptions);\n    } catch (error) {\n      return handleIPCError(error, 'splitPDF');\n    }\n  },\n\n  // ===== FORM OPERATIONS =====\n  extractFormData: (pdfData) => {\n    try {\n      if (!pdfData) {\n        throw new Error('PDF data required for form extraction');\n      }\n      return ipcRenderer.invoke('extract-form-data', pdfData);\n    } catch (error) {\n      return handleIPCError(error, 'extractFormData');\n    }\n  },\n  \n  fillFormData: (pdfData, formData) => {\n    try {\n      if (!pdfData || !formData) {\n        throw new Error('Invalid form filling parameters');\n      }\n      return ipcRenderer.invoke('fill-form-data', pdfData, formData);\n    } catch (error) {\n      return handleIPCError(error, 'fillFormData');\n    }\n  },\n\n  // ===== SECURITY OPERATIONS =====\n  encryptPDF: (pdfData, encryptionOptions) => {\n    try {\n      if (!pdfData || !encryptionOptions) {\n        throw new Error('Invalid encryption parameters');\n      }\n      return ipcRenderer.invoke('encrypt-pdf', pdfData, encryptionOptions);\n    } catch (error) {\n      return handleIPCError(error, 'encryptPDF');\n    }\n  },\n  \n  decryptPDF: (pdfData, password) => {\n    try {\n      if (!pdfData || !password) {\n        throw new Error('Invalid decryption parameters');\n      }\n      return ipcRenderer.invoke('decrypt-pdf', pdfData, password);\n    } catch (error) {\n      return handleIPCError(error, 'decryptPDF');\n    }\n  },\n\n  // ===== WORKFLOW MANAGEMENT =====\n  createWorkflow: (workflowData) => {\n    try {\n      if (!workflowData || !workflowData.name || !workflowData.steps) {\n        throw new Error('Invalid workflow data');\n      }\n      return ipcRenderer.invoke('create-workflow', workflowData);\n    } catch (error) {\n      return handleIPCError(error, 'createWorkflow');\n    }\n  },\n  \n  executeWorkflow: (workflowId, inputFiles) => {\n    try {\n      if (!workflowId || !inputFiles) {\n        throw new Error('Invalid workflow execution parameters');\n      }\n      return ipcRenderer.invoke('execute-workflow', workflowId, inputFiles);\n    } catch (error) {\n      return handleIPCError(error, 'executeWorkflow');\n    }\n  },\n  \n  onWorkflowProgress: (callback) => {\n    return setupProgressListener('workflow-progress', callback);\n  },\n\n  // ===== DOCUMENT COMPARISON =====\n  compareDocuments: (doc1Data, doc2Data, comparisonOptions) => {\n    try {\n      if (!doc1Data || !doc2Data) {\n        throw new Error('Two documents required for comparison');\n      }\n      return ipcRenderer.invoke('compare-documents', doc1Data, doc2Data, comparisonOptions);\n    } catch (error) {\n      return handleIPCError(error, 'compareDocuments');\n    }\n  },\n\n  // ===== ANALYTICS AND REPORTING =====\n  generateAnalyticsReport: (reportType, timeRange) => {\n    try {\n      const validReportTypes = ['usage', 'performance', 'security', 'compliance'];\n      if (!validReportTypes.includes(reportType)) {\n        throw new Error('Invalid report type');\n      }\n      return ipcRenderer.invoke('generate-analytics-report', reportType, timeRange);\n    } catch (error) {\n      return handleIPCError(error, 'generateAnalyticsReport');\n    }\n  },\n\n  // ===== ACCESSIBILITY TOOLS =====\n  checkAccessibility: (pdfData, standards) => {\n    try {\n      if (!pdfData) {\n        throw new Error('PDF data required for accessibility check');\n      }\n      return ipcRenderer.invoke('check-accessibility', pdfData, standards);\n    } catch (error) {\n      return handleIPCError(error, 'checkAccessibility');\n    }\n  },\n\n  // ===== PREFERENCES MANAGEMENT =====\n  getPreferences: () => {\n    try {\n      return ipcRenderer.invoke('get-preferences');\n    } catch (error) {\n      return handleIPCError(error, 'getPreferences');\n    }\n  },\n  \n  setPreferences: (preferences) => {\n    try {\n      if (!preferences || typeof preferences !== 'object') {\n        throw new Error('Invalid preferences object');\n      }\n      return ipcRenderer.invoke('set-preferences', preferences);\n    } catch (error) {\n      return handleIPCError(error, 'setPreferences');\n    }\n  },\n\n  // ===== RECENT FILES MANAGEMENT =====\n  getRecentFiles: () => {\n    try {\n      return ipcRenderer.invoke('get-recent-files');\n    } catch (error) {\n      return handleIPCError(error, 'getRecentFiles');\n    }\n  },\n  \n  addRecentFile: (filePath) => {\n    try {\n      if (!filePath || typeof filePath !== 'string') {\n        throw new Error('Invalid file path');\n      }\n      return ipcRenderer.invoke('add-recent-file', filePath);\n    } catch (error) {\n      return handleIPCError(error, 'addRecentFile');\n    }\n  },\n  \n  clearRecentFiles: () => {\n    try {\n      return ipcRenderer.invoke('clear-recent-files');\n    } catch (error) {\n      return handleIPCError(error, 'clearRecentFiles');\n    }\n  },\n\n  // ===== WINDOW MANAGEMENT =====\n  isMaximized: () => {\n    try {\n      return ipcRenderer.invoke('is-maximized');\n    } catch (error) {\n      return handleIPCError(error, 'isMaximized');\n    }\n  },\n  \n  minimizeWindow: () => {\n    try {\n      ipcRenderer.send('minimize-window');\n    } catch (error) {\n      console.error('Failed to minimize window:', error);\n    }\n  },\n  \n  maximizeWindow: () => {\n    try {\n      ipcRenderer.send('maximize-window');\n    } catch (error) {\n      console.error('Failed to maximize window:', error);\n    }\n  },\n  \n  closeWindow: () => {\n    try {\n      ipcRenderer.send('close-window');\n    } catch (error) {\n      console.error('Failed to close window:', error);\n    }\n  },\n  \n  setFullscreen: (flag) => {\n    try {\n      if (typeof flag !== 'boolean') {\n        throw new Error('Fullscreen flag must be boolean');\n      }\n      ipcRenderer.send('set-fullscreen', flag);\n    } catch (error) {\n      console.error('Failed to set fullscreen:', error);\n    }\n  },\n\n  // ===== SYSTEM INFORMATION =====\n  getPlatform: () => {\n    try {\n      return ipcRenderer.invoke('get-platform');\n    } catch (error) {\n      return handleIPCError(error, 'getPlatform');\n    }\n  },\n  \n  getVersion: () => {\n    try {\n      return ipcRenderer.invoke('get-version');\n    } catch (error) {\n      return handleIPCError(error, 'getVersion');\n    }\n  },\n\n  // ===== ERROR REPORTING =====\n  reportError: (error) => {\n    try {\n      if (!error) {\n        throw new Error('No error to report');\n      }\n      \n      // Sanitize error object to prevent injection\n      const sanitizedError = {\n        message: typeof error.message === 'string' ? error.message.substring(0, 500) : 'Unknown error',\n        code: typeof error.code === 'string' ? error.code.substring(0, 100) : undefined,\n        stack: typeof error.stack === 'string' ? error.stack.substring(0, 2000) : undefined,\n        timestamp: new Date().toISOString()\n      };\n      \n      ipcRenderer.send('renderer-error', sanitizedError);\n    } catch (reportError) {\n      console.error('Failed to report error:', reportError);\n    }\n  },\n\n  // ===== EVENT LISTENERS =====\n  onMenuAction: (callback) => {\n    try {\n      if (typeof callback !== 'function') {\n        throw new Error('Callback must be a function');\n      }\n      \n      const wrappedCallback = (event, action) => {\n        try {\n          // Validate action parameter\n          if (typeof action !== 'string' || action.length > 100) {\n            console.warn('Invalid menu action received:', action);\n            return;\n          }\n          callback(action);\n        } catch (error) {\n          console.error('Menu action callback error:', error);\n        }\n      };\n      \n      ipcRenderer.on('menu-action', wrappedCallback);\n      \n      // Return cleanup function\n      return () => {\n        ipcRenderer.removeListener('menu-action', wrappedCallback);\n      };\n    } catch (error) {\n      console.error('Failed to set menu action listener:', error);\n      return () => {}; // Return no-op cleanup function\n    }\n  },\n  \n  removeAllListeners: () => {\n    try {\n      // Remove all registered progress listeners\n      for (const [eventName, callback] of progressCallbacks) {\n        ipcRenderer.removeListener(eventName, callback);\n      }\n      progressCallbacks.clear();\n      \n      // Remove menu action listeners\n      ipcRenderer.removeAllListeners('menu-action');\n    } catch (error) {\n      console.error('Failed to remove listeners:', error);\n    }\n  },\n\n  // ===== UTILITY FUNCTIONS =====\n  \n  // Check if running in Electron\n  isElectron: () => true,\n  \n  // Get app information\n  getAppInfo: async () => {\n    try {\n      const [platform, version] = await Promise.all([\n        ipcRenderer.invoke('get-platform'),\n        ipcRenderer.invoke('get-version')\n      ]);\n      \n      return {\n        platform,\n        version,\n        isElectron: true,\n        contextIsolated: process.contextIsolated\n      };\n    } catch (error) {\n      return handleIPCError(error, 'getAppInfo');\n    }\n  },\n  \n  // Performance monitoring\n  getPerformanceInfo: () => {\n    try {\n      const memory = performance.memory;\n      return {\n        memory: memory ? {\n          used: memory.usedJSHeapSize,\n          total: memory.totalJSHeapSize,\n          limit: memory.jsHeapSizeLimit\n        } : null,\n        timing: {\n          navigationStart: performance.timeOrigin,\n          now: performance.now()\n        }\n      };\n    } catch (error) {\n      console.warn('Performance info not available:', error);\n      return null;\n    }\n  }\n};\n\n// Expose the API to the renderer process\ntry {\n  contextBridge.exposeInMainWorld('electronAPI', electronAPI);\n  console.log('‚úÖ Enhanced Electron API exposed successfully with premium features');\n} catch (error) {\n  console.error('‚ùå Failed to expose Electron API:', error);\n  throw error;\n}\n\n// Security validation on load\nwindow.addEventListener('DOMContentLoaded', () => {\n  try {\n    // Verify API is properly exposed\n    if (typeof window.electronAPI === 'undefined') {\n      throw new Error('Electron API not properly exposed');\n    }\n    \n    // Verify context isolation\n    if (typeof process !== 'undefined') {\n      console.warn('‚ö†Ô∏è Process object is accessible - context isolation may be compromised');\n    }\n    \n    // Verify Node.js integration is disabled\n    if (typeof require !== 'undefined') {\n      console.warn('‚ö†Ô∏è Require function is accessible - Node.js integration may be enabled');\n    }\n    \n    // Log available API methods for debugging\n    console.log('üìã Available API methods:', Object.keys(window.electronAPI));\n    \n    console.log('‚úÖ Enhanced security validation passed');\n  } catch (error) {\n    console.error('‚ùå Security validation failed:', error);\n  }\n});\n"