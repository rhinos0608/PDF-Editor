/**\n * Enhanced PDF Text Editor Service\n * Provides comprehensive text editing capabilities with proper PDF integration\n * Connects UI interactions with actual PDF modifications\n */\n\nimport { PDFDocument, PDFPage, rgb, StandardFonts, PDFFont, degrees } from 'pdf-lib';\nimport * as pdfjsLib from 'pdfjs-dist';\nimport { PDFDocumentProxy, PDFPageProxy } from 'pdfjs-dist/types/src/display/api';\nimport { createSafePDFBytes, validatePDFBytes } from '../../common/utils';\nimport { logger } from './LoggerService';\n\nexport interface TextEdit {\n  id: string;\n  pageIndex: number;\n  type: 'insert' | 'delete' | 'replace' | 'format';\n  position: { x: number; y: number };\n  originalText?: string;\n  newText?: string;\n  formatting?: TextFormatting;\n  bounds?: { x: number; y: number; width: number; height: number };\n  timestamp: Date;\n  applied: boolean;\n}\n\nexport interface TextFormatting {\n  fontSize?: number;\n  fontFamily?: string;\n  color?: { r: number; g: number; b: number };\n  bold?: boolean;\n  italic?: boolean;\n  underline?: boolean;\n  strikethrough?: boolean;\n  alignment?: 'left' | 'center' | 'right' | 'justify';\n  lineHeight?: number;\n  letterSpacing?: number;\n}\n\nexport interface TextSelection {\n  pageIndex: number;\n  startPosition: { x: number; y: number };\n  endPosition: { x: number; y: number };\n  text: string;\n  bounds: { x: number; y: number; width: number; height: number };\n}\n\nexport interface ExtractedTextItem {\n  text: string;\n  x: number;\n  y: number;\n  width: number;\n  height: number;\n  fontSize: number;\n  fontName: string;\n  color: { r: number; g: number; b: number };\n  transform: number[];\n}\n\nexport class EnhancedPDFTextEditor {\n  private textEdits: Map<string, TextEdit> = new Map();\n  private extractedText: Map<number, ExtractedTextItem[]> = new Map();\n  private currentSelection: TextSelection | null = null;\n  private isEditMode: boolean = false;\n  private currentPDF: PDFDocumentProxy | null = null;\n  private currentPDFBytes: Uint8Array | null = null;\n\n  /**\n   * Initialize the text editor with a PDF document\n   */\n  async initialize(pdf: PDFDocumentProxy, pdfBytes: Uint8Array): Promise<void> {\n    try {\n      this.currentPDF = pdf;\n      this.currentPDFBytes = createSafePDFBytes(pdfBytes);\n      \n      // Extract text from all pages for editing\n      await this.extractAllText();\n      \n      logger.info('PDF Text Editor initialized', {\n        pages: pdf.numPages,\n        bytesSize: pdfBytes.length\n      });\n    } catch (error) {\n      logger.error('Failed to initialize PDF Text Editor', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Extract text content from all PDF pages\n   */\n  private async extractAllText(): Promise<void> {\n    if (!this.currentPDF) {\n      throw new Error('No PDF loaded');\n    }\n\n    for (let pageNum = 1; pageNum <= this.currentPDF.numPages; pageNum++) {\n      try {\n        const page = await this.currentPDF.getPage(pageNum);\n        const textItems = await this.extractTextFromPage(page, pageNum - 1);\n        this.extractedText.set(pageNum - 1, textItems);\n      } catch (error) {\n        logger.warn(`Failed to extract text from page ${pageNum}`, error);\n        this.extractedText.set(pageNum - 1, []);\n      }\n    }\n  }\n\n  /**\n   * Extract text items from a specific page\n   */\n  private async extractTextFromPage(page: PDFPageProxy, pageIndex: number): Promise<ExtractedTextItem[]> {\n    try {\n      const textContent = await page.getTextContent();\n      const viewport = page.getViewport({ scale: 1.0 });\n      const textItems: ExtractedTextItem[] = [];\n\n      for (const item of textContent.items) {\n        if ('str' in item && item.str.trim()) {\n          // Transform coordinates to match PDF coordinate system\n          const transform = item.transform;\n          const x = transform[4];\n          const y = viewport.height - transform[5]; // Flip Y coordinate\n          const fontSize = Math.abs(transform[0]); // Font size from transform matrix\n          \n          textItems.push({\n            text: item.str,\n            x,\n            y,\n            width: item.width || 0,\n            height: item.height || fontSize,\n            fontSize,\n            fontName: item.fontName || 'Helvetica',\n            color: { r: 0, g: 0, b: 0 }, // Default to black\n            transform: transform\n          });\n        }\n      }\n\n      return textItems;\n    } catch (error) {\n      logger.error(`Failed to extract text from page ${pageIndex}`, error);\n      return [];\n    }\n  }\n\n  /**\n   * Enable or disable edit mode\n   */\n  setEditMode(enabled: boolean): void {\n    this.isEditMode = enabled;\n    logger.info(`Text edit mode ${enabled ? 'enabled' : 'disabled'}`);\n  }\n\n  /**\n   * Get current edit mode status\n   */\n  isInEditMode(): boolean {\n    return this.isEditMode;\n  }\n\n  /**\n   * Select text at the given coordinates\n   */\n  selectTextAt(pageIndex: number, x: number, y: number, width: number, height: number): TextSelection | null {\n    const pageText = this.extractedText.get(pageIndex);\n    if (!pageText) return null;\n\n    // Find text items within the selection bounds\n    const selectedItems = pageText.filter(item => {\n      return item.x >= x && item.x <= x + width &&\n             item.y >= y && item.y <= y + height;\n    });\n\n    if (selectedItems.length === 0) return null;\n\n    // Combine selected text\n    const text = selectedItems.map(item => item.text).join(' ');\n    \n    // Calculate selection bounds\n    const minX = Math.min(...selectedItems.map(item => item.x));\n    const minY = Math.min(...selectedItems.map(item => item.y));\n    const maxX = Math.max(...selectedItems.map(item => item.x + item.width));\n    const maxY = Math.max(...selectedItems.map(item => item.y + item.height));\n\n    this.currentSelection = {\n      pageIndex,\n      startPosition: { x: minX, y: minY },\n      endPosition: { x: maxX, y: maxY },\n      text,\n      bounds: { x: minX, y: minY, width: maxX - minX, height: maxY - minY }\n    };\n\n    logger.info('Text selected', {\n      pageIndex,\n      text: text.substring(0, 50) + (text.length > 50 ? '...' : ''),\n      bounds: this.currentSelection.bounds\n    });\n\n    return this.currentSelection;\n  }\n\n  /**\n   * Get current text selection\n   */\n  getCurrentSelection(): TextSelection | null {\n    return this.currentSelection;\n  }\n\n  /**\n   * Clear current text selection\n   */\n  clearSelection(): void {\n    this.currentSelection = null;\n  }\n\n  /**\n   * Insert text at the specified position\n   */\n  insertText(\n    pageIndex: number,\n    position: { x: number; y: number },\n    text: string,\n    formatting?: TextFormatting\n  ): string {\n    const editId = `insert_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n    \n    const edit: TextEdit = {\n      id: editId,\n      pageIndex,\n      type: 'insert',\n      position,\n      newText: text,\n      formatting: formatting || {\n        fontSize: 12,\n        fontFamily: 'Helvetica',\n        color: { r: 0, g: 0, b: 0 }\n      },\n      timestamp: new Date(),\n      applied: false\n    };\n\n    this.textEdits.set(editId, edit);\n    \n    logger.info('Text insertion queued', {\n      editId,\n      pageIndex,\n      text: text.substring(0, 50) + (text.length > 50 ? '...' : ''),\n      position\n    });\n\n    return editId;\n  }\n\n  /**\n   * Replace selected text with new text\n   */\n  replaceSelectedText(newText: string, formatting?: TextFormatting): string | null {\n    if (!this.currentSelection) {\n      throw new Error('No text selected');\n    }\n\n    const editId = `replace_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n    \n    const edit: TextEdit = {\n      id: editId,\n      pageIndex: this.currentSelection.pageIndex,\n      type: 'replace',\n      position: this.currentSelection.startPosition,\n      originalText: this.currentSelection.text,\n      newText,\n      formatting,\n      bounds: this.currentSelection.bounds,\n      timestamp: new Date(),\n      applied: false\n    };\n\n    this.textEdits.set(editId, edit);\n    \n    logger.info('Text replacement queued', {\n      editId,\n      pageIndex: this.currentSelection.pageIndex,\n      originalText: this.currentSelection.text.substring(0, 30) + '...',\n      newText: newText.substring(0, 30) + (newText.length > 30 ? '...' : '')\n    });\n\n    return editId;\n  }\n\n  /**\n   * Delete selected text\n   */\n  deleteSelectedText(): string | null {\n    if (!this.currentSelection) {\n      throw new Error('No text selected');\n    }\n\n    const editId = `delete_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n    \n    const edit: TextEdit = {\n      id: editId,\n      pageIndex: this.currentSelection.pageIndex,\n      type: 'delete',\n      position: this.currentSelection.startPosition,\n      originalText: this.currentSelection.text,\n      bounds: this.currentSelection.bounds,\n      timestamp: new Date(),\n      applied: false\n    };\n\n    this.textEdits.set(editId, edit);\n    \n    logger.info('Text deletion queued', {\n      editId,\n      pageIndex: this.currentSelection.pageIndex,\n      text: this.currentSelection.text.substring(0, 50) + '...'\n    });\n\n    return editId;\n  }\n\n  /**\n   * Apply formatting to selected text\n   */\n  formatSelectedText(formatting: TextFormatting): string | null {\n    if (!this.currentSelection) {\n      throw new Error('No text selected');\n    }\n\n    const editId = `format_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n    \n    const edit: TextEdit = {\n      id: editId,\n      pageIndex: this.currentSelection.pageIndex,\n      type: 'format',\n      position: this.currentSelection.startPosition,\n      originalText: this.currentSelection.text,\n      formatting,\n      bounds: this.currentSelection.bounds,\n      timestamp: new Date(),\n      applied: false\n    }\n\n    this.textEdits.set(editId, edit);\n    \n    logger.info('Text formatting queued', {\n      editId,\n      pageIndex: this.currentSelection.pageIndex,\n      formatting\n    });\n\n    return editId;\n  }\n\n  /**\n   * Get all pending text edits\n   */\n  getPendingEdits(): TextEdit[] {\n    return Array.from(this.textEdits.values()).filter(edit => !edit.applied);\n  }\n\n  /**\n   * Get text edits for a specific page\n   */\n  getPageEdits(pageIndex: number): TextEdit[] {\n    return Array.from(this.textEdits.values())\n      .filter(edit => edit.pageIndex === pageIndex);\n  }\n\n  /**\n   * Remove a text edit\n   */\n  removeEdit(editId: string): boolean {\n    const removed = this.textEdits.delete(editId);\n    if (removed) {\n      logger.info('Text edit removed', { editId });\n    }\n    return removed;\n  }\n\n  /**\n   * Clear all text edits\n   */\n  clearAllEdits(): void {\n    const count = this.textEdits.size;\n    this.textEdits.clear();\n    logger.info('All text edits cleared', { count });\n  }\n\n  /**\n   * Apply all pending text edits to the PDF\n   */\n  async applyEditsToPDF(): Promise<Uint8Array> {\n    if (!this.currentPDFBytes) {\n      throw new Error('No PDF bytes available');\n    }\n\n    const pendingEdits = this.getPendingEdits();\n    if (pendingEdits.length === 0) {\n      logger.info('No pending text edits to apply');\n      return this.currentPDFBytes;\n    }\n\n    try {\n      logger.info('Applying text edits to PDF', { editCount: pendingEdits.length });\n      \n      // Load PDF document for editing\n      const pdfDoc = await PDFDocument.load(this.currentPDFBytes);\n      const pages = pdfDoc.getPages();\n      \n      // Get fonts\n      const helvetica = await pdfDoc.embedFont(StandardFonts.Helvetica);\n      const helveticaBold = await pdfDoc.embedFont(StandardFonts.HelveticaBold);\n      const helveticaOblique = await pdfDoc.embedFont(StandardFonts.HelveticaOblique);\n      \n      // Group edits by page for efficient processing\n      const editsByPage = new Map<number, TextEdit[]>();\n      for (const edit of pendingEdits) {\n        if (!editsByPage.has(edit.pageIndex)) {\n          editsByPage.set(edit.pageIndex, []);\n        }\n        editsByPage.get(edit.pageIndex)!.push(edit);\n      }\n\n      // Apply edits page by page\n      for (const [pageIndex, pageEdits] of editsByPage) {\n        if (pageIndex >= pages.length) {\n          logger.warn(`Page index ${pageIndex} out of bounds, skipping edits`);\n          continue;\n        }\n\n        const page = pages[pageIndex];\n        const { height } = page.getSize();\n\n        for (const edit of pageEdits) {\n          try {\n            await this.applyEditToPage(page, edit, height, {\n              helvetica,\n              helveticaBold,\n              helveticaOblique\n            });\n            edit.applied = true;\n          } catch (error) {\n            logger.error(`Failed to apply edit ${edit.id}`, error);\n          }\n        }\n      }\n\n      // Save the modified PDF\n      const modifiedBytes = await pdfDoc.save({\n        useObjectStreams: false,\n        addDefaultPage: false,\n        updateFieldAppearances: true\n      });\n\n      const result = createSafePDFBytes(modifiedBytes);\n      \n      // Update current PDF bytes\n      this.currentPDFBytes = result;\n      \n      logger.info('Text edits applied successfully', {\n        appliedEdits: pendingEdits.filter(e => e.applied).length,\n        resultSize: result.length\n      });\n\n      return result;\n    } catch (error) {\n      logger.error('Failed to apply text edits to PDF', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Apply a single edit to a PDF page\n   */\n  private async applyEditToPage(\n    page: PDFPage,\n    edit: TextEdit,\n    pageHeight: number,\n    fonts: { helvetica: PDFFont; helveticaBold: PDFFont; helveticaOblique: PDFFont }\n  ): Promise<void> {\n    const formatting = edit.formatting || {\n      fontSize: 12,\n      fontFamily: 'Helvetica',\n      color: { r: 0, g: 0, b: 0 }\n    };\n\n    // Select appropriate font\n    let font = fonts.helvetica;\n    if (formatting.bold && formatting.italic) {\n      font = fonts.helveticaOblique; // Best approximation\n    } else if (formatting.bold) {\n      font = fonts.helveticaBold;\n    } else if (formatting.italic) {\n      font = fonts.helveticaOblique;\n    }\n\n    const fontSize = formatting.fontSize || 12;\n    const color = formatting.color || { r: 0, g: 0, b: 0 };\n    \n    // Convert coordinates (PDF.js uses top-left origin, pdf-lib uses bottom-left)\n    const y = pageHeight - edit.position.y - fontSize;\n\n    switch (edit.type) {\n      case 'insert':\n        if (edit.newText) {\n          page.drawText(edit.newText, {\n            x: edit.position.x,\n            y,\n            size: fontSize,\n            font,\n            color: rgb(color.r, color.g, color.b)\n          });\n        }\n        break;\n\n      case 'replace':\n        // For replace, we need to cover the original text and draw new text\n        if (edit.bounds) {\n          // Draw a white rectangle to cover original text\n          page.drawRectangle({\n            x: edit.bounds.x,\n            y: pageHeight - edit.bounds.y - edit.bounds.height,\n            width: edit.bounds.width,\n            height: edit.bounds.height,\n            color: rgb(1, 1, 1) // White\n          });\n        }\n        \n        if (edit.newText) {\n          page.drawText(edit.newText, {\n            x: edit.position.x,\n            y,\n            size: fontSize,\n            font,\n            color: rgb(color.r, color.g, color.b)\n          });\n        }\n        break;\n\n      case 'delete':\n        // Cover the text with a white rectangle\n        if (edit.bounds) {\n          page.drawRectangle({\n            x: edit.bounds.x,\n            y: pageHeight - edit.bounds.y - edit.bounds.height,\n            width: edit.bounds.width,\n            height: edit.bounds.height,\n            color: rgb(1, 1, 1) // White\n          });\n        }\n        break;\n\n      case 'format':\n        // For formatting, redraw the text with new formatting\n        if (edit.bounds) {\n          // Cover original text\n          page.drawRectangle({\n            x: edit.bounds.x,\n            y: pageHeight - edit.bounds.y - edit.bounds.height,\n            width: edit.bounds.width,\n            height: edit.bounds.height,\n            color: rgb(1, 1, 1) // White\n          });\n        }\n        \n        if (edit.originalText) {\n          page.drawText(edit.originalText, {\n            x: edit.position.x,\n            y,\n            size: fontSize,\n            font,\n            color: rgb(color.r, color.g, color.b)\n          });\n        }\n        break;\n    }\n  }\n\n  /**\n   * Get extracted text for a specific page\n   */\n  getPageText(pageIndex: number): ExtractedTextItem[] {\n    return this.extractedText.get(pageIndex) || [];\n  }\n\n  /**\n   * Search for text in the document\n   */\n  searchText(query: string, caseSensitive: boolean = false): Array<{\n    pageIndex: number;\n    item: ExtractedTextItem;\n    matchIndex: number;\n  }> {\n    const results: Array<{\n      pageIndex: number;\n      item: ExtractedTextItem;\n      matchIndex: number;\n    }> = [];\n\n    const searchQuery = caseSensitive ? query : query.toLowerCase();\n\n    for (const [pageIndex, textItems] of this.extractedText) {\n      for (const item of textItems) {\n        const text = caseSensitive ? item.text : item.text.toLowerCase();\n        const matchIndex = text.indexOf(searchQuery);\n        \n        if (matchIndex !== -1) {\n          results.push({\n            pageIndex,\n            item,\n            matchIndex\n          });\n        }\n      }\n    }\n\n    return results;\n  }\n\n  /**\n   * Get statistics about the text content\n   */\n  getTextStatistics(): {\n    totalPages: number;\n    totalTextItems: number;\n    totalCharacters: number;\n    averageItemsPerPage: number;\n    pendingEdits: number;\n  } {\n    let totalTextItems = 0;\n    let totalCharacters = 0;\n\n    for (const textItems of this.extractedText.values()) {\n      totalTextItems += textItems.length;\n      totalCharacters += textItems.reduce((sum, item) => sum + item.text.length, 0);\n    }\n\n    return {\n      totalPages: this.extractedText.size,\n      totalTextItems,\n      totalCharacters,\n      averageItemsPerPage: totalTextItems / Math.max(1, this.extractedText.size),\n      pendingEdits: this.getPendingEdits().length\n    };\n  }\n\n  /**\n   * Export text edits to JSON\n   */\n  exportEdits(): string {\n    const edits = Array.from(this.textEdits.values());\n    return JSON.stringify(edits, null, 2);\n  }\n\n  /**\n   * Import text edits from JSON\n   */\n  importEdits(json: string): void {\n    try {\n      const edits = JSON.parse(json) as TextEdit[];\n      this.textEdits.clear();\n      \n      for (const edit of edits) {\n        this.textEdits.set(edit.id, edit);\n      }\n      \n      logger.info('Text edits imported', { count: edits.length });\n    } catch (error) {\n      logger.error('Failed to import text edits', error);\n      throw new Error('Invalid text edits JSON format');\n    }\n  }\n\n  /**\n   * Cleanup resources\n   */\n  cleanup(): void {\n    this.textEdits.clear();\n    this.extractedText.clear();\n    this.currentSelection = null;\n    this.isEditMode = false;\n    this.currentPDF = null;\n    this.currentPDFBytes = null;\n    \n    logger.info('PDF Text Editor cleaned up');\n  }\n}\n"