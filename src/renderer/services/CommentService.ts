import { PDFDocument, PDFPage, rgb, StandardFonts, degrees } from 'pdf-lib';

export interface Comment {
  id: string;
  type: 'note' | 'highlight' | 'strikethrough' | 'underline' | 'squiggly' | 'freetext' | 'stamp' | 'ink' | 'popup';
  pageNumber: number;
  x: number;
  y: number;
  width?: number;
  height?: number;
  author: string;
  content: string;
  createdDate: Date;
  modifiedDate: Date;
  color: { r: number; g: number; b: number };
  opacity: number;
  isOpen: boolean;
  replyTo?: string;
  replies: string[];
  status: 'none' | 'review' | 'approved' | 'rejected' | 'completed' | 'cancelled';
  priority: 'low' | 'normal' | 'high' | 'urgent';
  category?: string;
  customProperties?: Record<string, any>;
}

export interface TextMarkup extends Comment {
  type: 'highlight' | 'strikethrough' | 'underline' | 'squiggly';
  textQuads: Array<{ x: number; y: number; width: number; height: number }>;
  selectedText: string;
}

export interface FreeTextAnnotation extends Comment {
  type: 'freetext';
  fontSize: number;
  fontFamily: string;
  fontStyle: 'normal' | 'bold' | 'italic' | 'bold-italic';
  textAlignment: 'left' | 'center' | 'right' | 'justify';
  borderWidth: number;
  borderColor: { r: number; g: number; b: number };
  backgroundColor: { r: number; g: number; b: number };
}

export interface StampAnnotation extends Comment {
  type: 'stamp';
  stampType: 'approved' | 'rejected' | 'confidential' | 'draft' | 'final' | 'reviewed' | 'custom';
  customStampText?: string;
  rotation: number;
}

export interface InkAnnotation extends Comment {
  type: 'ink';
  paths: Array<Array<{ x: number; y: number; pressure?: number }>>;
  lineWidth: number;
  lineCap: 'butt' | 'round' | 'square';
  lineJoin: 'miter' | 'round' | 'bevel';
}

export interface ReviewSession {
  id: string;
  name: string;
  description: string;
  reviewers: string[];
  deadLine?: Date;
  status: 'active' | 'completed' | 'cancelled';
  createdBy: string;
  createdDate: Date;
  settings: {
    allowComments: boolean;\n    allowMarkups: boolean;\n    allowStamps: boolean;\n    requireApproval: boolean;\n    anonymousReviews: boolean;\n    autoNotifications: boolean;\n  };\n}\n\nexport interface ReviewWorkflow {\n  id: string;\n  name: string;\n  steps: ReviewWorkflowStep[];\n  currentStep: number;\n  isSequential: boolean;\n  autoAdvance: boolean;\n}\n\nexport interface ReviewWorkflowStep {\n  id: string;\n  name: string;\n  description: string;\n  assignees: string[];\n  requiredApprovals: number;\n  allowedActions: ('comment' | 'approve' | 'reject' | 'modify')[];\n  timeLimit?: number; // hours\n  autoEscalation?: {\n    enabled: boolean;\n    escalateTo: string[];\n    afterHours: number;\n  };\n}\n\nexport interface ReviewStatistics {\n  totalComments: number;\n  commentsByType: Record<Comment['type'], number>;\n  commentsByAuthor: Record<string, number>;\n  commentsByStatus: Record<Comment['status'], number>;\n  commentsByPriority: Record<Comment['priority'], number>;\n  averageResponseTime: number; // hours\n  resolutionRate: number; // percentage\n  activeReviewers: number;\n  completedReviews: number;\n}\n\nexport interface CommentThread {\n  id: string;\n  rootComment: Comment;\n  replies: Comment[];\n  participants: string[];\n  isResolved: boolean;\n  resolvedBy?: string;\n  resolvedDate?: Date;\n}\n\nexport class CommentService {\n  private comments: Map<string, Comment> = new Map();\n  private reviewSessions: Map<string, ReviewSession> = new Map();\n  private workflows: Map<string, ReviewWorkflow> = new Map();\n  private commentThreads: Map<string, CommentThread> = new Map();\n\n  /**\n   * Add comment to PDF\n   */\n  async addComment(\n    pdfBytes: Uint8Array,\n    comment: Omit<Comment, 'id' | 'createdDate' | 'modifiedDate' | 'replies'>\n  ): Promise<{ pdfBytes: Uint8Array; commentId: string }> {\n    try {\n      const commentId = this.generateId();\n      const now = new Date();\n      \n      const newComment: Comment = {\n        ...comment,\n        id: commentId,\n        createdDate: now,\n        modifiedDate: now,\n        replies: []\n      };\n\n      this.comments.set(commentId, newComment);\n\n      // Create thread if this is a root comment\n      if (!comment.replyTo) {\n        const thread: CommentThread = {\n          id: this.generateId(),\n          rootComment: newComment,\n          replies: [],\n          participants: [comment.author],\n          isResolved: false\n        };\n        this.commentThreads.set(thread.id, thread);\n      } else {\n        // Add to existing thread\n        const parentComment = this.comments.get(comment.replyTo);\n        if (parentComment) {\n          parentComment.replies.push(commentId);\n          \n          // Find and update the thread\n          for (const thread of this.commentThreads.values()) {\n            if (thread.rootComment.id === comment.replyTo || thread.replies.some(r => r.id === comment.replyTo)) {\n              thread.replies.push(newComment);\n              if (!thread.participants.includes(comment.author)) {\n                thread.participants.push(comment.author);\n              }\n              break;\n            }\n          }\n        }\n      }\n\n      // Add visual annotation to PDF\n      const pdfDoc = await PDFDocument.load(pdfBytes);\n      const page = pdfDoc.getPage(comment.pageNumber - 1);\n      \n      await this.renderCommentOnPage(page, newComment, pdfDoc);\n\n      // Store comment metadata\n      const commentData = {\n        comments: Array.from(this.comments.values()),\n        threads: Array.from(this.commentThreads.values())\n      };\n      \n      pdfDoc.setKeywords(`COMMENTS:${JSON.stringify(commentData)}`);\n\n      return {\n        pdfBytes: await pdfDoc.save(),\n        commentId\n      };\n    } catch (error) {\n      console.error('Error adding comment:', error);\n      throw new Error('Failed to add comment');\n    }\n  }\n\n  /**\n   * Update comment\n   */\n  async updateComment(\n    pdfBytes: Uint8Array,\n    commentId: string,\n    updates: Partial<Comment>\n  ): Promise<Uint8Array> {\n    try {\n      const comment = this.comments.get(commentId);\n      if (!comment) {\n        throw new Error('Comment not found');\n      }\n\n      // Update comment\n      Object.assign(comment, updates, { modifiedDate: new Date() });\n      this.comments.set(commentId, comment);\n\n      // Update thread if status changed to resolved\n      if (updates.status && ['approved', 'completed'].includes(updates.status)) {\n        for (const thread of this.commentThreads.values()) {\n          if (thread.rootComment.id === commentId) {\n            thread.isResolved = true;\n            thread.resolvedBy = updates.author || comment.author;\n            thread.resolvedDate = new Date();\n            break;\n          }\n        }\n      }\n\n      // Re-render PDF with updated comments\n      return await this.rerenderPDFWithComments(pdfBytes);\n    } catch (error) {\n      console.error('Error updating comment:', error);\n      throw new Error('Failed to update comment');\n    }\n  }\n\n  /**\n   * Delete comment\n   */\n  async deleteComment(\n    pdfBytes: Uint8Array,\n    commentId: string\n  ): Promise<Uint8Array> {\n    try {\n      const comment = this.comments.get(commentId);\n      if (!comment) {\n        throw new Error('Comment not found');\n      }\n\n      // Remove replies first\n      for (const replyId of comment.replies) {\n        await this.deleteComment(pdfBytes, replyId);\n      }\n\n      // Remove from parent's replies if it's a reply\n      if (comment.replyTo) {\n        const parent = this.comments.get(comment.replyTo);\n        if (parent) {\n          parent.replies = parent.replies.filter(id => id !== commentId);\n        }\n      }\n\n      // Remove from thread\n      for (const thread of this.commentThreads.values()) {\n        if (thread.rootComment.id === commentId) {\n          this.commentThreads.delete(thread.id);\n          break;\n        } else {\n          thread.replies = thread.replies.filter(r => r.id !== commentId);\n        }\n      }\n\n      // Remove comment\n      this.comments.delete(commentId);\n\n      // Re-render PDF\n      return await this.rerenderPDFWithComments(pdfBytes);\n    } catch (error) {\n      console.error('Error deleting comment:', error);\n      throw new Error('Failed to delete comment');\n    }\n  }\n\n  /**\n   * Add text markup annotation\n   */\n  async addTextMarkup(\n    pdfBytes: Uint8Array,\n    markup: Omit<TextMarkup, 'id' | 'createdDate' | 'modifiedDate' | 'replies'>\n  ): Promise<{ pdfBytes: Uint8Array; commentId: string }> {\n    const result = await this.addComment(pdfBytes, markup);\n    return result;\n  }\n\n  /**\n   * Add freetext annotation\n   */\n  async addFreeText(\n    pdfBytes: Uint8Array,\n    annotation: Omit<FreeTextAnnotation, 'id' | 'createdDate' | 'modifiedDate' | 'replies'>\n  ): Promise<{ pdfBytes: Uint8Array; commentId: string }> {\n    const result = await this.addComment(pdfBytes, annotation);\n    return result;\n  }\n\n  /**\n   * Add stamp annotation\n   */\n  async addStamp(\n    pdfBytes: Uint8Array,\n    stamp: Omit<StampAnnotation, 'id' | 'createdDate' | 'modifiedDate' | 'replies'>\n  ): Promise<{ pdfBytes: Uint8Array; commentId: string }> {\n    const result = await this.addComment(pdfBytes, stamp);\n    return result;\n  }\n\n  /**\n   * Add ink annotation (drawing)\n   */\n  async addInkAnnotation(\n    pdfBytes: Uint8Array,\n    ink: Omit<InkAnnotation, 'id' | 'createdDate' | 'modifiedDate' | 'replies'>\n  ): Promise<{ pdfBytes: Uint8Array; commentId: string }> {\n    const result = await this.addComment(pdfBytes, ink);\n    return result;\n  }\n\n  /**\n   * Create review session\n   */\n  createReviewSession(\n    session: Omit<ReviewSession, 'id' | 'createdDate'>\n  ): string {\n    const sessionId = this.generateId();\n    const reviewSession: ReviewSession = {\n      ...session,\n      id: sessionId,\n      createdDate: new Date()\n    };\n    \n    this.reviewSessions.set(sessionId, reviewSession);\n    return sessionId;\n  }\n\n  /**\n   * Start review workflow\n   */\n  async startReviewWorkflow(\n    pdfBytes: Uint8Array,\n    workflowId: string,\n    sessionId: string\n  ): Promise<Uint8Array> {\n    try {\n      const workflow = this.workflows.get(workflowId);\n      const session = this.reviewSessions.get(sessionId);\n      \n      if (!workflow || !session) {\n        throw new Error('Workflow or session not found');\n      }\n\n      // Reset workflow to first step\n      workflow.currentStep = 0;\n      \n      // Add workflow metadata to PDF\n      const pdfDoc = await PDFDocument.load(pdfBytes);\n      const workflowData = {\n        workflowId,\n        sessionId,\n        startedAt: new Date().toISOString(),\n        currentStep: workflow.currentStep\n      };\n      \n      pdfDoc.setCreator(`WORKFLOW:${JSON.stringify(workflowData)}`);\n      \n      return await pdfDoc.save();\n    } catch (error) {\n      console.error('Error starting review workflow:', error);\n      throw new Error('Failed to start review workflow');\n    }\n  }\n\n  /**\n   * Get review statistics\n   */\n  getReviewStatistics(): ReviewStatistics {\n    const comments = Array.from(this.comments.values());\n    \n    const stats: ReviewStatistics = {\n      totalComments: comments.length,\n      commentsByType: {} as Record<Comment['type'], number>,\n      commentsByAuthor: {} as Record<string, number>,\n      commentsByStatus: {} as Record<Comment['status'], number>,\n      commentsByPriority: {} as Record<Comment['priority'], number>,\n      averageResponseTime: 0,\n      resolutionRate: 0,\n      activeReviewers: 0,\n      completedReviews: 0\n    };\n\n    // Calculate statistics\n    comments.forEach(comment => {\n      // By type\n      stats.commentsByType[comment.type] = (stats.commentsByType[comment.type] || 0) + 1;\n      \n      // By author\n      stats.commentsByAuthor[comment.author] = (stats.commentsByAuthor[comment.author] || 0) + 1;\n      \n      // By status\n      stats.commentsByStatus[comment.status] = (stats.commentsByStatus[comment.status] || 0) + 1;\n      \n      // By priority\n      stats.commentsByPriority[comment.priority] = (stats.commentsByPriority[comment.priority] || 0) + 1;\n    });\n\n    // Calculate response time (simplified)\n    const resolvedComments = comments.filter(c => ['approved', 'completed', 'rejected'].includes(c.status));\n    if (resolvedComments.length > 0) {\n      const totalResponseTime = resolvedComments.reduce((sum, comment) => {\n        const responseTime = comment.modifiedDate.getTime() - comment.createdDate.getTime();\n        return sum + responseTime;\n      }, 0);\n      stats.averageResponseTime = totalResponseTime / resolvedComments.length / (1000 * 60 * 60); // Convert to hours\n    }\n\n    // Calculate resolution rate\n    stats.resolutionRate = resolvedComments.length / comments.length * 100;\n    \n    // Calculate active reviewers\n    const uniqueAuthors = new Set(comments.map(c => c.author));\n    stats.activeReviewers = uniqueAuthors.size;\n    \n    // Calculate completed reviews\n    stats.completedReviews = Array.from(this.reviewSessions.values())\n      .filter(session => session.status === 'completed').length;\n\n    return stats;\n  }\n\n  /**\n   * Export comments to various formats\n   */\n  exportComments(\n    format: 'json' | 'csv' | 'pdf' | 'docx' = 'json',\n    options: {\n      includeReplies?: boolean;\n      filterByAuthor?: string;\n      filterByStatus?: Comment['status'];\n      filterByType?: Comment['type'];\n    } = {}\n  ): string {\n    let comments = Array.from(this.comments.values());\n    \n    // Apply filters\n    if (options.filterByAuthor) {\n      comments = comments.filter(c => c.author === options.filterByAuthor);\n    }\n    if (options.filterByStatus) {\n      comments = comments.filter(c => c.status === options.filterByStatus);\n    }\n    if (options.filterByType) {\n      comments = comments.filter(c => c.type === options.filterByType);\n    }\n    \n    switch (format) {\n      case 'json':\n        return JSON.stringify({\n          comments,\n          threads: Array.from(this.commentThreads.values()),\n          exportedAt: new Date().toISOString()\n        }, null, 2);\n        \n      case 'csv':\n        let csv = 'ID,Type,Author,Content,Page,Status,Priority,Created,Modified\\n';\n        comments.forEach(comment => {\n          const content = comment.content.replace(/\"/g, '\"\"').replace(/\\n/g, ' ');\n          csv += `\"${comment.id}\",\"${comment.type}\",\"${comment.author}\",\"${content}\",\"${comment.pageNumber}\",\"${comment.status}\",\"${comment.priority}\",\"${comment.createdDate.toISOString()}\",\"${comment.modifiedDate.toISOString()}\"\\n`;\n        });\n        return csv;\n        \n      default:\n        return this.exportComments('json', options);\n    }\n  }\n\n  /**\n   * Generate comment summary report\n   */\n  generateCommentReport(): {\n    summary: string;\n    openIssues: Comment[];\n    resolvedIssues: Comment[];\n    recommendations: string[];\n  } {\n    const comments = Array.from(this.comments.values());\n    const openIssues = comments.filter(c => !['approved', 'completed', 'rejected'].includes(c.status));\n    const resolvedIssues = comments.filter(c => ['approved', 'completed', 'rejected'].includes(c.status));\n    \n    const summary = `\n      Document Review Summary:\n      - Total Comments: ${comments.length}\n      - Open Issues: ${openIssues.length}\n      - Resolved Issues: ${resolvedIssues.length}\n      - Resolution Rate: ${((resolvedIssues.length / comments.length) * 100).toFixed(1)}%\n      - Active Threads: ${Array.from(this.commentThreads.values()).filter(t => !t.isResolved).length}\n    `;\n    \n    const recommendations = [];\n    \n    if (openIssues.length > 10) {\n      recommendations.push('Consider prioritizing comment resolution - high number of open issues');\n    }\n    \n    const urgentIssues = openIssues.filter(c => c.priority === 'urgent');\n    if (urgentIssues.length > 0) {\n      recommendations.push(`${urgentIssues.length} urgent issue(s) require immediate attention`);\n    }\n    \n    const oldIssues = openIssues.filter(c => \n      (new Date().getTime() - c.createdDate.getTime()) > (7 * 24 * 60 * 60 * 1000)\n    );\n    if (oldIssues.length > 0) {\n      recommendations.push(`${oldIssues.length} issue(s) have been open for more than a week`);\n    }\n    \n    return {\n      summary,\n      openIssues,\n      resolvedIssues,\n      recommendations\n    };\n  }\n\n  // Helper methods\n\n  private generateId(): string {\n    return 'comment_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);\n  }\n\n  private async renderCommentOnPage(\n    page: PDFPage,\n    comment: Comment,\n    pdfDoc: PDFDocument\n  ): Promise<void> {\n    const { x, y, width = 0, height = 0 } = comment;\n    const color = rgb(comment.color.r, comment.color.g, comment.color.b);\n    \n    switch (comment.type) {\n      case 'note':\n        // Draw note icon\n        page.drawRectangle({\n          x: x - 8,\n          y: y - 8,\n          width: 16,\n          height: 16,\n          color: rgb(1, 1, 0),\n          borderColor: rgb(0.8, 0.8, 0),\n          borderWidth: 1\n        });\n        \n        // Add note marker\n        const font = await pdfDoc.embedFont(StandardFonts.Helvetica);\n        page.drawText('!', {\n          x: x - 4,\n          y: y - 4,\n          size: 10,\n          font,\n          color: rgb(0, 0, 0)\n        });\n        break;\n        \n      case 'highlight':\n        const textMarkup = comment as TextMarkup;\n        textMarkup.textQuads.forEach(quad => {\n          page.drawRectangle({\n            x: quad.x,\n            y: quad.y,\n            width: quad.width,\n            height: quad.height,\n            color,\n            opacity: comment.opacity\n          });\n        });\n        break;\n        \n      case 'strikethrough':\n        const strikethrough = comment as TextMarkup;\n        strikethrough.textQuads.forEach(quad => {\n          page.drawLine({\n            start: { x: quad.x, y: quad.y + quad.height / 2 },\n            end: { x: quad.x + quad.width, y: quad.y + quad.height / 2 },\n            thickness: 2,\n            color,\n            opacity: comment.opacity\n          });\n        });\n        break;\n        \n      case 'freetext':\n        const freetext = comment as FreeTextAnnotation;\n        \n        // Draw background\n        page.drawRectangle({\n          x,\n          y,\n          width: width || 200,\n          height: height || 50,\n          color: rgb(freetext.backgroundColor.r, freetext.backgroundColor.g, freetext.backgroundColor.b),\n          borderColor: rgb(freetext.borderColor.r, freetext.borderColor.g, freetext.borderColor.b),\n          borderWidth: freetext.borderWidth\n        });\n        \n        // Draw text\n        const freetextFont = await pdfDoc.embedFont(StandardFonts.Helvetica);\n        page.drawText(comment.content, {\n          x: x + 5,\n          y: y + (height || 50) - freetext.fontSize - 5,\n          size: freetext.fontSize,\n          font: freetextFont,\n          color\n        });\n        break;\n        \n      case 'stamp':\n        const stamp = comment as StampAnnotation;\n        const stampText = stamp.customStampText || stamp.stampType.toUpperCase();\n        \n        // Draw stamp background\n        page.drawRectangle({\n          x,\n          y,\n          width: width || 100,\n          height: height || 30,\n          color: rgb(1, 0.9, 0.9),\n          borderColor: rgb(0.8, 0, 0),\n          borderWidth: 2\n        });\n        \n        // Draw stamp text\n        const stampFont = await pdfDoc.embedFont(StandardFonts.HelveticaBold);\n        page.drawText(stampText, {\n          x: x + 10,\n          y: y + 10,\n          size: 12,\n          font: stampFont,\n          color: rgb(0.8, 0, 0),\n          rotate: degrees(stamp.rotation)\n        });\n        break;\n        \n      case 'ink':\n        const ink = comment as InkAnnotation;\n        ink.paths.forEach(path => {\n          for (let i = 1; i < path.length; i++) {\n            page.drawLine({\n              start: { x: path[i-1].x, y: path[i-1].y },\n              end: { x: path[i].x, y: path[i].y },\n              thickness: ink.lineWidth,\n              color,\n              opacity: comment.opacity\n            });\n          }\n        });\n        break;\n    }\n  }\n\n  private async rerenderPDFWithComments(pdfBytes: Uint8Array): Promise<Uint8Array> {\n    try {\n      const pdfDoc = await PDFDocument.load(pdfBytes);\n      \n      // Clear existing comment renderings (simplified - in production, track rendered comments)\n      // Re-render all comments\n      for (const comment of this.comments.values()) {\n        const page = pdfDoc.getPage(comment.pageNumber - 1);\n        await this.renderCommentOnPage(page, comment, pdfDoc);\n      }\n      \n      // Update metadata\n      const commentData = {\n        comments: Array.from(this.comments.values()),\n        threads: Array.from(this.commentThreads.values())\n      };\n      \n      pdfDoc.setKeywords(`COMMENTS:${JSON.stringify(commentData)}`);\n      \n      return await pdfDoc.save();\n    } catch (error) {\n      console.error('Error re-rendering PDF with comments:', error);\n      throw new Error('Failed to re-render PDF with comments');\n    }\n  }\n\n  /**\n   * Get all comments\n   */\n  getAllComments(): Comment[] {\n    return Array.from(this.comments.values());\n  }\n\n  /**\n   * Get comment by ID\n   */\n  getComment(id: string): Comment | undefined {\n    return this.comments.get(id);\n  }\n\n  /**\n   * Get comments by page\n   */\n  getCommentsByPage(pageNumber: number): Comment[] {\n    return Array.from(this.comments.values())\n      .filter(comment => comment.pageNumber === pageNumber);\n  }\n\n  /**\n   * Get comment threads\n   */\n  getCommentThreads(): CommentThread[] {\n    return Array.from(this.commentThreads.values());\n  }\n\n  /**\n   * Search comments\n   */\n  searchComments(query: string, options: {\n    searchContent?: boolean;\n    searchAuthor?: boolean;\n    caseSensitive?: boolean;\n  } = {}): Comment[] {\n    const {\n      searchContent = true,\n      searchAuthor = true,\n      caseSensitive = false\n    } = options;\n    \n    const searchTerm = caseSensitive ? query : query.toLowerCase();\n    \n    return Array.from(this.comments.values()).filter(comment => {\n      if (searchContent) {\n        const content = caseSensitive ? comment.content : comment.content.toLowerCase();\n        if (content.includes(searchTerm)) return true;\n      }\n      \n      if (searchAuthor) {\n        const author = caseSensitive ? comment.author : comment.author.toLowerCase();\n        if (author.includes(searchTerm)) return true;\n      }\n      \n      return false;\n    });\n  }\n}\n\nexport default CommentService;