import { PDFDocument, PDFPage } from 'pdf-lib';\nimport { PDFDocumentProxy, PDFPageProxy } from 'pdfjs-dist/types/src/display/api';\n\nexport interface PerformanceMetrics {\n  memoryUsage: {\n    used: number;\n    total: number;\n    percentage: number;\n  };\n  renderingTime: {\n    averagePageRender: number;\n    totalRenderTime: number;\n    pagesRendered: number;\n  };\n  loadingTime: {\n    documentLoad: number;\n    pageLoad: number;\n  };\n  documentStats: {\n    fileSize: number;\n    pageCount: number;\n    averagePageSize: number;\n    complexityScore: number;\n  };\n  optimizationLevel: 'none' | 'basic' | 'moderate' | 'aggressive';\n}\n\nexport interface OptimizationSettings {\n  enableVirtualization: boolean;\n  pagePreloadCount: number;\n  maxCachedPages: number;\n  renderQuality: 'low' | 'medium' | 'high';\n  enableTextLayerOptimization: boolean;\n  enableImageOptimization: boolean;\n  enableFontSubsetting: boolean;\n  enableContentStreamOptimization: boolean;\n  enableBackgroundProcessing: boolean;\n  memoryThreshold: number; // MB\n  enableWorkerThreads: boolean;\n  workerThreadCount: number;\n}\n\nexport interface PageCache {\n  pageNumber: number;\n  canvas: HTMLCanvasElement;\n  textLayer?: HTMLElement;\n  timestamp: number;\n  renderTime: number;\n  memorySize: number;\n  quality: number;\n}\n\nexport interface RenderJob {\n  id: string;\n  pageNumber: number;\n  priority: 'low' | 'normal' | 'high' | 'urgent';\n  quality: number;\n  viewport: any;\n  callback: (result: PageCache) => void;\n  startTime: number;\n  retryCount: number;\n}\n\nexport interface MemoryPool {\n  canvases: HTMLCanvasElement[];\n  contexts: CanvasRenderingContext2D[];\n  workers: Worker[];\n  maxSize: number;\n  currentSize: number;\n}\n\nexport interface DocumentAnalysis {\n  pageComplexity: number[];\n  hasImages: boolean;\n  hasTransparency: boolean;\n  hasForms: boolean;\n  hasAnnotations: boolean;\n  hasJavaScript: boolean;\n  fontCount: number;\n  imageCount: number;\n  totalTextLength: number;\n  averagePageComplexity: number;\n  recommendedSettings: OptimizationSettings;\n}\n\nexport class PerformanceOptimizer {\n  private metrics: PerformanceMetrics;\n  private settings: OptimizationSettings;\n  private pageCache: Map<number, PageCache> = new Map();\n  private renderQueue: RenderJob[] = [];\n  private memoryPool: MemoryPool;\n  private isProcessing: boolean = false;\n  private performanceObserver?: PerformanceObserver;\n  private workers: Worker[] = [];\n  private documentAnalysis?: DocumentAnalysis;\n\n  constructor(settings?: Partial<OptimizationSettings>) {\n    this.settings = {\n      enableVirtualization: true,\n      pagePreloadCount: 5,\n      maxCachedPages: 20,\n      renderQuality: 'medium',\n      enableTextLayerOptimization: true,\n      enableImageOptimization: true,\n      enableFontSubsetting: false,\n      enableContentStreamOptimization: false,\n      enableBackgroundProcessing: true,\n      memoryThreshold: 500, // 500MB\n      enableWorkerThreads: true,\n      workerThreadCount: Math.max(2, Math.floor(navigator.hardwareConcurrency / 2)),\n      ...settings\n    };\n\n    this.metrics = this.initializeMetrics();\n    this.memoryPool = this.initializeMemoryPool();\n    \n    this.initializePerformanceMonitoring();\n    this.initializeWorkers();\n    this.startRenderProcessor();\n  }\n\n  /**\n   * Analyze document for performance optimization\n   */\n  async analyzeDocument(pdf: PDFDocumentProxy): Promise<DocumentAnalysis> {\n    const startTime = performance.now();\n    \n    const analysis: DocumentAnalysis = {\n      pageComplexity: [],\n      hasImages: false,\n      hasTransparency: false,\n      hasForms: false,\n      hasAnnotations: false,\n      hasJavaScript: false,\n      fontCount: 0,\n      imageCount: 0,\n      totalTextLength: 0,\n      averagePageComplexity: 0,\n      recommendedSettings: { ...this.settings }\n    };\n\n    // Analyze first few pages to estimate complexity\n    const samplesToAnalyze = Math.min(5, pdf.numPages);\n    \n    for (let i = 1; i <= samplesToAnalyze; i++) {\n      const page = await pdf.getPage(i);\n      const complexity = await this.calculatePageComplexity(page);\n      analysis.pageComplexity.push(complexity);\n    }\n\n    // Extrapolate complexity for remaining pages\n    const avgComplexity = analysis.pageComplexity.reduce((a, b) => a + b, 0) / analysis.pageComplexity.length;\n    for (let i = samplesToAnalyze + 1; i <= pdf.numPages; i++) {\n      analysis.pageComplexity.push(avgComplexity);\n    }\n\n    analysis.averagePageComplexity = avgComplexity;\n\n    // Check document features\n    const firstPage = await pdf.getPage(1);\n    const viewport = firstPage.getViewport({ scale: 1 });\n    \n    try {\n      // Check for forms\n      const formData = await pdf.getForm();\n      analysis.hasForms = formData && Object.keys(formData).length > 0;\n    } catch {\n      analysis.hasForms = false;\n    }\n\n    try {\n      // Check for JavaScript\n      analysis.hasJavaScript = pdf.getData().then(data => {\n        const textDecoder = new TextDecoder();\n        const pdfText = textDecoder.decode(data.slice(0, Math.min(10000, data.length)));\n        return pdfText.includes('/JavaScript') || pdfText.includes('/JS');\n      }).catch(() => false);\n    } catch {\n      analysis.hasJavaScript = false;\n    }\n\n    // Generate recommendations based on analysis\n    analysis.recommendedSettings = this.generateOptimizationRecommendations(analysis);\n    \n    const analysisTime = performance.now() - startTime;\n    this.metrics.loadingTime.documentLoad = analysisTime;\n    \n    this.documentAnalysis = analysis;\n    return analysis;\n  }\n\n  /**\n   * Calculate page complexity score\n   */\n  private async calculatePageComplexity(page: PDFPageProxy): Promise<number> {\n    let complexity = 0;\n    \n    try {\n      // Base complexity from page size\n      const viewport = page.getViewport({ scale: 1 });\n      complexity += (viewport.width * viewport.height) / 100000; // Normalize by 100k pixels\n      \n      // Check for text content\n      const textContent = await page.getTextContent();\n      const textComplexity = textContent.items.length * 0.1;\n      complexity += textComplexity;\n      \n      // Check for operators (simplified)\n      const operators = await page.getOperatorList();\n      const operatorComplexity = operators.fnArray.length * 0.05;\n      complexity += operatorComplexity;\n      \n      // Penalize for large number of graphics operations\n      const graphicsOps = operators.fnArray.filter(op => \n        op.toString().includes('Image') || \n        op.toString().includes('Path') || \n        op.toString().includes('Fill')\n      ).length;\n      complexity += graphicsOps * 0.2;\n      \n    } catch (error) {\n      console.warn('Error calculating page complexity:', error);\n      complexity = 5; // Default moderate complexity\n    }\n    \n    return Math.max(1, Math.min(10, complexity)); // Clamp between 1-10\n  }\n\n  /**\n   * Generate optimization recommendations\n   */\n  private generateOptimizationRecommendations(analysis: DocumentAnalysis): OptimizationSettings {\n    const recommendations = { ...this.settings };\n    \n    if (analysis.averagePageComplexity > 7) {\n      // High complexity documents\n      recommendations.renderQuality = 'low';\n      recommendations.pagePreloadCount = 2;\n      recommendations.maxCachedPages = 10;\n      recommendations.enableBackgroundProcessing = true;\n      recommendations.enableWorkerThreads = true;\n    } else if (analysis.averagePageComplexity > 4) {\n      // Medium complexity documents\n      recommendations.renderQuality = 'medium';\n      recommendations.pagePreloadCount = 3;\n      recommendations.maxCachedPages = 15;\n    } else {\n      // Low complexity documents\n      recommendations.renderQuality = 'high';\n      recommendations.pagePreloadCount = 7;\n      recommendations.maxCachedPages = 25;\n    }\n    \n    if (analysis.hasImages) {\n      recommendations.enableImageOptimization = true;\n    }\n    \n    if (analysis.hasForms) {\n      recommendations.enableTextLayerOptimization = false; // Forms need accurate text layers\n    }\n    \n    // Memory-based adjustments\n    const availableMemory = this.getAvailableMemory();\n    if (availableMemory < 1000) { // Less than 1GB\n      recommendations.maxCachedPages = Math.max(5, Math.floor(recommendations.maxCachedPages / 2));\n      recommendations.pagePreloadCount = Math.max(1, Math.floor(recommendations.pagePreloadCount / 2));\n    }\n    \n    return recommendations;\n  }\n\n  /**\n   * Render page with optimization\n   */\n  async renderPageOptimized(\n    page: PDFPageProxy,\n    pageNumber: number,\n    scale: number = 1,\n    priority: RenderJob['priority'] = 'normal'\n  ): Promise<PageCache> {\n    // Check cache first\n    const cached = this.pageCache.get(pageNumber);\n    if (cached && this.isCacheValid(cached, scale)) {\n      cached.timestamp = Date.now(); // Update access time\n      return cached;\n    }\n\n    // Create render job\n    const jobId = this.generateId();\n    const viewport = page.getViewport({ scale });\n    \n    return new Promise((resolve) => {\n      const job: RenderJob = {\n        id: jobId,\n        pageNumber,\n        priority,\n        quality: this.getQualityFromSettings(),\n        viewport,\n        callback: resolve,\n        startTime: performance.now(),\n        retryCount: 0\n      };\n      \n      this.addToRenderQueue(job);\n    });\n  }\n\n  /**\n   * Preload pages for smooth scrolling\n   */\n  async preloadPages(\n    pdf: PDFDocumentProxy,\n    currentPage: number,\n    direction: 'forward' | 'backward' | 'both' = 'both'\n  ): Promise<void> {\n    if (!this.settings.enableBackgroundProcessing) {\n      return;\n    }\n\n    const pagesToPreload: number[] = [];\n    const preloadCount = this.settings.pagePreloadCount;\n    \n    if (direction === 'forward' || direction === 'both') {\n      for (let i = 1; i <= preloadCount; i++) {\n        const pageNum = currentPage + i;\n        if (pageNum <= pdf.numPages && !this.pageCache.has(pageNum)) {\n          pagesToPreload.push(pageNum);\n        }\n      }\n    }\n    \n    if (direction === 'backward' || direction === 'both') {\n      for (let i = 1; i <= preloadCount; i++) {\n        const pageNum = currentPage - i;\n        if (pageNum >= 1 && !this.pageCache.has(pageNum)) {\n          pagesToPreload.push(pageNum);\n        }\n      }\n    }\n\n    // Preload pages with low priority\n    for (const pageNum of pagesToPreload) {\n      try {\n        const page = await pdf.getPage(pageNum);\n        this.renderPageOptimized(page, pageNum, 1, 'low');\n      } catch (error) {\n        console.warn(`Failed to preload page ${pageNum}:`, error);\n      }\n    }\n  }\n\n  /**\n   * Optimize PDF for better performance\n   */\n  async optimizePDF(\n    pdfBytes: Uint8Array,\n    optimizationLevel: 'basic' | 'moderate' | 'aggressive' = 'moderate'\n  ): Promise<Uint8Array> {\n    try {\n      const pdfDoc = await PDFDocument.load(pdfBytes);\n      \n      // Apply optimizations based on level\n      switch (optimizationLevel) {\n        case 'basic':\n          return await this.applyBasicOptimizations(pdfDoc);\n        case 'moderate':\n          return await this.applyModerateOptimizations(pdfDoc);\n        case 'aggressive':\n          return await this.applyAggressiveOptimizations(pdfDoc);\n        default:\n          return pdfBytes;\n      }\n    } catch (error) {\n      console.error('PDF optimization failed:', error);\n      return pdfBytes;\n    }\n  }\n\n  /**\n   * Apply basic optimizations\n   */\n  private async applyBasicOptimizations(pdfDoc: PDFDocument): Promise<Uint8Array> {\n    // Remove unused objects and compress\n    return await pdfDoc.save({\n      useObjectStreams: true,\n      addDefaultPage: false,\n      compress: true\n    });\n  }\n\n  /**\n   * Apply moderate optimizations\n   */\n  private async applyModerateOptimizations(pdfDoc: PDFDocument): Promise<Uint8Array> {\n    // Basic optimizations plus content stream optimization\n    return await pdfDoc.save({\n      useObjectStreams: true,\n      addDefaultPage: false,\n      compress: true,\n      objectsPerTick: 200\n    });\n  }\n\n  /**\n   * Apply aggressive optimizations\n   */\n  private async applyAggressiveOptimizations(pdfDoc: PDFDocument): Promise<Uint8Array> {\n    // All optimizations plus metadata removal\n    pdfDoc.setTitle('');\n    pdfDoc.setAuthor('');\n    pdfDoc.setSubject('');\n    pdfDoc.setCreator('');\n    pdfDoc.setProducer('Optimized');\n    pdfDoc.setKeywords([]);\n    \n    return await pdfDoc.save({\n      useObjectStreams: true,\n      addDefaultPage: false,\n      compress: true,\n      objectsPerTick: 100,\n      updateFieldAppearances: false\n    });\n  }\n\n  /**\n   * Manage memory usage\n   */\n  private manageMemory(): void {\n    const currentMemory = this.getCurrentMemoryUsage();\n    \n    if (currentMemory > this.settings.memoryThreshold * 1024 * 1024) { // Convert MB to bytes\n      this.performMemoryCleanup();\n    }\n    \n    // Update metrics\n    this.metrics.memoryUsage = {\n      used: currentMemory,\n      total: this.getTotalMemory(),\n      percentage: (currentMemory / this.getTotalMemory()) * 100\n    };\n  }\n\n  /**\n   * Perform memory cleanup\n   */\n  private performMemoryCleanup(): void {\n    // Sort cache by last access time (oldest first)\n    const cacheEntries = Array.from(this.pageCache.entries())\n      .sort((a, b) => a[1].timestamp - b[1].timestamp);\n    \n    // Remove oldest entries until under threshold\n    const maxCached = Math.floor(this.settings.maxCachedPages * 0.7); // Keep 70% of max\n    \n    while (this.pageCache.size > maxCached && cacheEntries.length > 0) {\n      const [pageNumber] = cacheEntries.shift()!;\n      this.removeCachedPage(pageNumber);\n    }\n    \n    // Force garbage collection if available\n    if ('gc' in window && typeof (window as any).gc === 'function') {\n      (window as any).gc();\n    }\n  }\n\n  /**\n   * Remove cached page and free resources\n   */\n  private removeCachedPage(pageNumber: number): void {\n    const cached = this.pageCache.get(pageNumber);\n    if (cached) {\n      // Return canvas to pool\n      this.returnCanvasToPool(cached.canvas);\n      \n      // Remove text layer if exists\n      if (cached.textLayer) {\n        cached.textLayer.remove();\n      }\n      \n      this.pageCache.delete(pageNumber);\n    }\n  }\n\n  /**\n   * Initialize performance monitoring\n   */\n  private initializePerformanceMonitoring(): void {\n    if ('PerformanceObserver' in window) {\n      this.performanceObserver = new PerformanceObserver((list) => {\n        for (const entry of list.getEntries()) {\n          if (entry.name.includes('pdf-render')) {\n            this.updateRenderingMetrics(entry.duration);\n          }\n        }\n      });\n      \n      this.performanceObserver.observe({ entryTypes: ['measure'] });\n    }\n    \n    // Monitor memory usage periodically\n    setInterval(() => {\n      this.manageMemory();\n    }, 10000); // Every 10 seconds\n  }\n\n  /**\n   * Update rendering metrics\n   */\n  private updateRenderingMetrics(renderTime: number): void {\n    this.metrics.renderingTime.totalRenderTime += renderTime;\n    this.metrics.renderingTime.pagesRendered++;\n    this.metrics.renderingTime.averagePageRender = \n      this.metrics.renderingTime.totalRenderTime / this.metrics.renderingTime.pagesRendered;\n  }\n\n  /**\n   * Initialize worker threads\n   */\n  private initializeWorkers(): void {\n    if (!this.settings.enableWorkerThreads || !('Worker' in window)) {\n      return;\n    }\n\n    const workerCode = `\n      self.onmessage = function(e) {\n        const { type, data } = e.data;\n        \n        switch (type) {\n          case 'render':\n            // Worker-based rendering logic would go here\n            self.postMessage({ type: 'renderComplete', data: data });\n            break;\n          \n          case 'optimize':\n            // Worker-based optimization logic would go here\n            self.postMessage({ type: 'optimizeComplete', data: data });\n            break;\n        }\n      };\n    `;\n    \n    const blob = new Blob([workerCode], { type: 'application/javascript' });\n    const workerUrl = URL.createObjectURL(blob);\n    \n    for (let i = 0; i < this.settings.workerThreadCount; i++) {\n      try {\n        const worker = new Worker(workerUrl);\n        worker.onmessage = this.handleWorkerMessage.bind(this);\n        worker.onerror = this.handleWorkerError.bind(this);\n        this.workers.push(worker);\n      } catch (error) {\n        console.warn('Failed to create worker:', error);\n      }\n    }\n    \n    URL.revokeObjectURL(workerUrl);\n  }\n\n  /**\n   * Handle worker messages\n   */\n  private handleWorkerMessage(event: MessageEvent): void {\n    const { type, data } = event.data;\n    \n    switch (type) {\n      case 'renderComplete':\n        // Handle completed render job\n        break;\n      \n      case 'optimizeComplete':\n        // Handle completed optimization job\n        break;\n    }\n  }\n\n  /**\n   * Handle worker errors\n   */\n  private handleWorkerError(error: ErrorEvent): void {\n    console.error('Worker error:', error);\n  }\n\n  /**\n   * Get performance metrics\n   */\n  getMetrics(): PerformanceMetrics {\n    return { ...this.metrics };\n  }\n\n  /**\n   * Update optimization settings\n   */\n  updateSettings(newSettings: Partial<OptimizationSettings>): void {\n    this.settings = { ...this.settings, ...newSettings };\n    \n    // Apply new cache limits\n    if (newSettings.maxCachedPages && this.pageCache.size > newSettings.maxCachedPages) {\n      this.performMemoryCleanup();\n    }\n  }\n\n  /**\n   * Get current settings\n   */\n  getSettings(): OptimizationSettings {\n    return { ...this.settings };\n  }\n\n  /**\n   * Clear all caches\n   */\n  clearCache(): void {\n    for (const pageNumber of this.pageCache.keys()) {\n      this.removeCachedPage(pageNumber);\n    }\n    this.pageCache.clear();\n  }\n\n  /**\n   * Get cache statistics\n   */\n  getCacheStats(): {\n    cachedPages: number;\n    totalMemoryUsed: number;\n    averageRenderTime: number;\n    cacheHitRatio: number;\n  } {\n    const cacheEntries = Array.from(this.pageCache.values());\n    \n    return {\n      cachedPages: this.pageCache.size,\n      totalMemoryUsed: cacheEntries.reduce((total, cache) => total + cache.memorySize, 0),\n      averageRenderTime: cacheEntries.length > 0 \n        ? cacheEntries.reduce((total, cache) => total + cache.renderTime, 0) / cacheEntries.length \n        : 0,\n      cacheHitRatio: this.metrics.renderingTime.pagesRendered > 0 \n        ? (this.pageCache.size / this.metrics.renderingTime.pagesRendered) * 100 \n        : 0\n    };\n  }\n\n  /**\n   * Dispose resources\n   */\n  dispose(): void {\n    // Clear caches\n    this.clearCache();\n    \n    // Terminate workers\n    this.workers.forEach(worker => worker.terminate());\n    this.workers = [];\n    \n    // Disconnect performance observer\n    if (this.performanceObserver) {\n      this.performanceObserver.disconnect();\n    }\n    \n    // Clear render queue\n    this.renderQueue = [];\n  }\n\n  // Helper methods\n\n  private initializeMetrics(): PerformanceMetrics {\n    return {\n      memoryUsage: {\n        used: 0,\n        total: this.getTotalMemory(),\n        percentage: 0\n      },\n      renderingTime: {\n        averagePageRender: 0,\n        totalRenderTime: 0,\n        pagesRendered: 0\n      },\n      loadingTime: {\n        documentLoad: 0,\n        pageLoad: 0\n      },\n      documentStats: {\n        fileSize: 0,\n        pageCount: 0,\n        averagePageSize: 0,\n        complexityScore: 0\n      },\n      optimizationLevel: 'none'\n    };\n  }\n\n  private initializeMemoryPool(): MemoryPool {\n    return {\n      canvases: [],\n      contexts: [],\n      workers: [],\n      maxSize: 20,\n      currentSize: 0\n    };\n  }\n\n  private generateId(): string {\n    return 'render_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);\n  }\n\n  private isCacheValid(cache: PageCache, scale: number): boolean {\n    const ageLimit = 300000; // 5 minutes\n    const age = Date.now() - cache.timestamp;\n    \n    // Cache is valid if it's recent and quality is sufficient\n    return age < ageLimit && cache.quality >= this.getQualityFromSettings();\n  }\n\n  private getQualityFromSettings(): number {\n    switch (this.settings.renderQuality) {\n      case 'low': return 1;\n      case 'medium': return 2;\n      case 'high': return 3;\n      default: return 2;\n    }\n  }\n\n  private addToRenderQueue(job: RenderJob): void {\n    // Insert based on priority\n    const priorities = { urgent: 0, high: 1, normal: 2, low: 3 };\n    const jobPriority = priorities[job.priority];\n    \n    let insertIndex = this.renderQueue.length;\n    for (let i = 0; i < this.renderQueue.length; i++) {\n      if (priorities[this.renderQueue[i].priority] > jobPriority) {\n        insertIndex = i;\n        break;\n      }\n    }\n    \n    this.renderQueue.splice(insertIndex, 0, job);\n  }\n\n  private startRenderProcessor(): void {\n    const processQueue = async () => {\n      if (this.isProcessing || this.renderQueue.length === 0) {\n        return;\n      }\n      \n      this.isProcessing = true;\n      const job = this.renderQueue.shift();\n      \n      if (job) {\n        try {\n          const result = await this.processRenderJob(job);\n          job.callback(result);\n        } catch (error) {\n          console.error('Render job failed:', error);\n          // Retry logic could go here\n        }\n      }\n      \n      this.isProcessing = false;\n    };\n    \n    // Process queue every 16ms (60 FPS)\n    setInterval(processQueue, 16);\n  }\n\n  private async processRenderJob(job: RenderJob): Promise<PageCache> {\n    const startTime = performance.now();\n    \n    // Get or create canvas\n    const canvas = this.getCanvasFromPool() || document.createElement('canvas');\n    const context = canvas.getContext('2d')!;\n    \n    canvas.width = job.viewport.width;\n    canvas.height = job.viewport.height;\n    \n    // Simulate rendering (actual implementation would use PDF.js)\n    // In real implementation, this would render the page to canvas\n    const renderTime = performance.now() - startTime;\n    \n    const cache: PageCache = {\n      pageNumber: job.pageNumber,\n      canvas,\n      timestamp: Date.now(),\n      renderTime,\n      memorySize: canvas.width * canvas.height * 4, // Rough estimate\n      quality: job.quality\n    };\n    \n    // Store in cache\n    this.pageCache.set(job.pageNumber, cache);\n    \n    // Update metrics\n    this.updateRenderingMetrics(renderTime);\n    \n    return cache;\n  }\n\n  private getCanvasFromPool(): HTMLCanvasElement | null {\n    if (this.memoryPool.canvases.length > 0) {\n      return this.memoryPool.canvases.pop()!;\n    }\n    return null;\n  }\n\n  private returnCanvasToPool(canvas: HTMLCanvasElement): void {\n    if (this.memoryPool.canvases.length < this.memoryPool.maxSize) {\n      // Clear canvas\n      const context = canvas.getContext('2d')!;\n      context.clearRect(0, 0, canvas.width, canvas.height);\n      \n      this.memoryPool.canvases.push(canvas);\n    }\n  }\n\n  private getCurrentMemoryUsage(): number {\n    // Use performance.memory if available\n    if ('memory' in performance && (performance as any).memory) {\n      return (performance as any).memory.usedJSHeapSize;\n    }\n    \n    // Fallback: estimate based on cached pages\n    return Array.from(this.pageCache.values())\n      .reduce((total, cache) => total + cache.memorySize, 0);\n  }\n\n  private getTotalMemory(): number {\n    if ('memory' in performance && (performance as any).memory) {\n      return (performance as any).memory.totalJSHeapSize;\n    }\n    \n    // Fallback estimate\n    return 2 * 1024 * 1024 * 1024; // 2GB\n  }\n\n  private getAvailableMemory(): number {\n    return this.getTotalMemory() - this.getCurrentMemoryUsage();\n  }\n}\n\nexport default PerformanceOptimizer;